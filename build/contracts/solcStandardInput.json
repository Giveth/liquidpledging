{
  "language": "Solidity",
  "sources": {
    "./contracts/LPConstants.sol": {
      "keccak256": "0x558e8800a807b65c952c7d731ca1c5c42539d734df4d545f801ecff0f0cd2314",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LPConstants.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"@aragon/os/contracts/kernel/KernelStorage.sol\";\n\ncontract LPConstants is KernelConstants {\n    bytes32 constant public VAULT_APP_ID = keccak256(\"vault\");\n    bytes32 constant public LP_APP_ID = keccak256(\"liquidPledging\");\n}"
    },
    "./contracts/ILiquidPledgingPlugin.sol": {
      "keccak256": "0x539d0f5e161acbabc3284727028de768be1405f22acbf515038266a3981c8e92",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/ILiquidPledgingPlugin.sol"
      ],
      "content": "pragma solidity ^0.4.0;\n\n/*\n    Copyright 2018, Jordi Baylina\n    Contributors: Adri√† Massanet <adria@codecontext.io>, RJ Ewing, Griff\n    Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/// @dev `ILiquidPledgingPlugin` is the basic interface for any\n///  liquid pledging plugin\ncontract ILiquidPledgingPlugin {\n\n    /// @notice Plugins are used (much like web hooks) to initiate an action\n    ///  upon any donation, delegation, or transfer; this is an optional feature\n    ///  and allows for extreme customization of the contract. This function\n    ///  implements any action that should be initiated before a transfer.\n    /// @param pledgeManager The admin or current manager of the pledge\n    /// @param pledgeFrom This is the Id from which value will be transfered.\n    /// @param pledgeTo This is the Id that value will be transfered to.    \n    /// @param context The situation that is triggering the plugin:\n    ///  0 -> Plugin for the owner transferring pledge to another party\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\n    ///  ...\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n    ///\n    ///  256 -> Plugin for the owner receiving pledge to another party\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\n    ///  ...\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n    /// @param amount The amount of value that will be transfered.\n    function beforeTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount ) public returns (uint maxAllowed);\n\n    /// @notice Plugins are used (much like web hooks) to initiate an action\n    ///  upon any donation, delegation, or transfer; this is an optional feature\n    ///  and allows for extreme customization of the contract. This function\n    ///  implements any action that should be initiated after a transfer.\n    /// @param pledgeManager The admin or current manager of the pledge\n    /// @param pledgeFrom This is the Id from which value will be transfered.\n    /// @param pledgeTo This is the Id that value will be transfered to.    \n    /// @param context The situation that is triggering the plugin:\n    ///  0 -> Plugin for the owner transferring pledge to another party\n    ///  1 -> Plugin for the first delegate transferring pledge to another party\n    ///  2 -> Plugin for the second delegate transferring pledge to another party\n    ///  ...\n    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n    ///\n    ///  256 -> Plugin for the owner receiving pledge to another party\n    ///  257 -> Plugin for the first delegate receiving pledge to another party\n    ///  258 -> Plugin for the second delegate receiving pledge to another party\n    ///  ...\n    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n    ///  @param amount The amount of value that will be transfered.\n    function afterTransfer(\n        uint64 pledgeManager,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        address token,\n        uint amount\n    ) public;\n}\n"
    },
    "./contracts/LPFactory.sol": {
      "keccak256": "0xda02f23a8a195b05bc500cd9c9638a148844eb6659b22140d759f96019cca8ba",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LPFactory.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"@aragon/os/contracts/factory/DAOFactory.sol\";\nimport \"./LPVault.sol\";\nimport \"./LiquidPledging.sol\";\nimport \"./LPConstants.sol\";\n\ncontract LPFactory is LPConstants, DAOFactory(new Kernel(), new ACL(), 0) {\n    bytes32 public constant RECOVERY_VAULT_ID = keccak256(\"recoveryVault\");\n    address public vaultBase;\n    address public lpBase;\n\n    event DeployVault(address vault);\n    event DeployLiquidPledging(address liquidPledging);\n\n    function LPFactory(address _vaultBase, address _lpBase) public {\n        require(_vaultBase != 0);\n        require(_lpBase != 0);\n        vaultBase = _vaultBase;\n        lpBase = _lpBase;\n    }\n\n    function newLP(address _root, address _escapeHatchDestination) external {\n        Kernel kernel = newDAO(this);\n        ACL acl = ACL(kernel.acl());\n\n        bytes32 appManagerRole = kernel.APP_MANAGER_ROLE();\n\n        acl.createPermission(this, address(kernel), appManagerRole, this);\n\n        LPVault v = LPVault(kernel.newAppInstance(VAULT_APP_ID, vaultBase));\n        // deploy & register the lp instance w/ the kernel\n        LiquidPledging lp = LiquidPledging(kernel.newAppInstance(LP_APP_ID, lpBase, true));\n        v.initialize(address(lp));\n        lp.initialize(address(v));\n\n        // set the recoveryVault to the escapeHatchDestination\n        kernel.setRecoveryVaultId(RECOVERY_VAULT_ID);\n        kernel.setApp(APP_ADDR_NAMESPACE, RECOVERY_VAULT_ID, _escapeHatchDestination);\n\n        _setPermissions(_root, acl, kernel, v, lp);\n    }\n\n    function _setPermissions(address _root, ACL acl, Kernel kernel, LPVault v, LiquidPledging lp) internal {\n        bytes32 appManagerRole = kernel.APP_MANAGER_ROLE();\n        bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n        bytes32 hatchCallerRole = v.ESCAPE_HATCH_CALLER_ROLE();\n        bytes32 pluginManagerRole = lp.PLUGIN_MANAGER_ROLE();\n\n        acl.createPermission(_root, address(v), hatchCallerRole, _root);\n        acl.createPermission(_root, address(lp), pluginManagerRole, _root);\n\n        acl.grantPermission(_root, address(kernel), appManagerRole);\n        acl.grantPermission(_root, address(acl), permRole);\n        acl.revokePermission(this, address(kernel), appManagerRole);\n        acl.revokePermission(this, address(acl), permRole);\n\n        acl.setPermissionManager(_root, address(kernel), appManagerRole);\n        acl.setPermissionManager(_root, address(acl), permRole);\n\n        DeployVault(address(v));\n        DeployLiquidPledging(address(lp));\n    }\n}"
    },
    "@aragon/os/contracts/kernel/KernelProxy.sol": {
      "keccak256": "0xe05c9e5170bbba66ad978aefb3367558124d4cb9d2bada024a6eae63f8d392b1",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/kernel/KernelProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./KernelStorage.sol\";\nimport \"../common/DepositableDelegateProxy.sol\";\n\n\ncontract KernelProxy is KernelStorage, DepositableDelegateProxy {\n    /**\n    * @dev KernelProxy is a proxy contract to a kernel implementation. The implementation\n    *      can update the reference, which effectively upgrades the contract\n    * @param _kernelImpl Address of the contract used as implementation for kernel\n    */\n    function KernelProxy(address _kernelImpl) public {\n        apps[keccak256(CORE_NAMESPACE, KERNEL_APP_ID)] = _kernelImpl;\n    }\n\n    /**\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n     */\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return UPGRADEABLE;\n    }\n\n    /**\n    * @dev ERC897, the address the proxy would delegate calls to\n    */\n    function implementation() public view returns (address) {\n        return apps[KERNEL_APP];\n    }\n\n}\n"
    },
    "@aragon/os/contracts/evmscript/EVMScriptRegistry.sol": {
      "keccak256": "0xfe0be3118e4c05855852a4791688b3de86b4f2c450d870b78c5642d6085e3f90",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/evmscript/EVMScriptRegistry.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./ScriptHelpers.sol\";\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"../apps/AragonApp.sol\";\n\n\ncontract EVMScriptRegistry is IEVMScriptRegistry, EVMScriptRegistryConstants, AragonApp {\n    using ScriptHelpers for bytes;\n\n    // WARN: Manager can censor all votes and the like happening in an org\n    // bytes32 constant public REGISTRY_MANAGER_ROLE = keccak256(\"REGISTRY_MANAGER_ROLE\");\n    bytes32 constant public REGISTRY_MANAGER_ROLE = 0xf7a450ef335e1892cb42c8ca72e7242359d7711924b75db5717410da3f614aa3;\n\n    struct ExecutorEntry {\n        address executor;\n        bool enabled;\n    }\n\n    ExecutorEntry[] public executors;\n\n    function initialize() onlyInit public {\n        initialized();\n        // Create empty record to begin executor IDs at 1\n        executors.push(ExecutorEntry(address(0), false));\n    }\n\n    function addScriptExecutor(address _executor) external auth(REGISTRY_MANAGER_ROLE) returns (uint id) {\n        return executors.push(ExecutorEntry(_executor, true));\n    }\n\n    function disableScriptExecutor(uint256 _executorId) external auth(REGISTRY_MANAGER_ROLE) {\n        executors[_executorId].enabled = false;\n    }\n\n    function getScriptExecutor(bytes _script) public view returns (address) {\n        uint256 id = _script.getSpecId();\n\n        if (id == 0 || id >= executors.length) {\n            return address(0);\n        }\n\n        ExecutorEntry storage entry = executors[id];\n        return entry.enabled ? entry.executor : address(0);\n    }\n}\n"
    },
    "@aragon/os/contracts/evmscript/executors/CallsScript.sol": {
      "keccak256": "0x75d416a2eb37b8c6b85e21a99f77daec09b9f6a93a103b8648f3f767fb383b3a",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/evmscript/executors/CallsScript.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n// Inspired by https://github.com/reverendus/tx-manager\n\nimport \"../ScriptHelpers.sol\";\nimport \"../IEVMScriptExecutor.sol\";\n\n\ncontract CallsScript is IEVMScriptExecutor {\n    using ScriptHelpers for bytes;\n\n    uint256 constant internal SCRIPT_START_LOCATION = 4;\n\n    event LogScriptCall(address indexed sender, address indexed src, address indexed dst);\n\n    /**\n    * @notice Executes a number of call scripts\n    * @param _script [ specId (uint32) ] many calls with this structure ->\n    *    [ to (address: 20 bytes) ] [ calldataLength (uint32: 4 bytes) ] [ calldata (calldataLength bytes) ]\n    * @param _input Input is ignored in callscript\n    * @param _blacklist Addresses the script cannot call to, or will revert.\n    * @return always returns empty byte array\n    */\n    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n        uint256 location = SCRIPT_START_LOCATION; // first 32 bits are spec id\n        while (location < _script.length) {\n            address contractAddress = _script.addressAt(location);\n            // Check address being called is not blacklist\n            for (uint i = 0; i < _blacklist.length; i++) {\n                require(contractAddress != _blacklist[i]);\n            }\n\n            // logged before execution to ensure event ordering in receipt\n            // if failed entire execution is reverted regardless\n            LogScriptCall(msg.sender, address(this), contractAddress);\n\n            uint256 calldataLength = uint256(_script.uint32At(location + 0x14));\n            uint256 startOffset = location + 0x14 + 0x04;\n            uint256 calldataStart = _script.locationOf(startOffset);\n\n            // compute end of script / next location\n            location = startOffset + calldataLength;\n            require(location <= _script.length);\n\n            assembly {\n                let success := call(sub(gas, 5000), contractAddress, 0, calldataStart, calldataLength, 0, 0)\n                switch success case 0 { revert(0, 0) }\n            }\n        }\n\n        bytes memory ret = new bytes(1);\n        ret[0] = 0x01;\n\n        return ret;\n    }\n}\n"
    },
    "@aragon/os/contracts/evmscript/executors/DelegateScript.sol": {
      "keccak256": "0xd51580ef89a6d926d6712fec5c2363b94b21f186532f09f598d2ea6afb332602",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/evmscript/executors/DelegateScript.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../ScriptHelpers.sol\";\nimport \"../IEVMScriptExecutor.sol\";\nimport \"../../common/IsContract.sol\";\n\n\ninterface DelegateScriptTarget {\n    function exec() public returns (bool);\n}\n\n\ncontract DelegateScript is IEVMScriptExecutor, IsContract {\n    using ScriptHelpers for *;\n\n    uint256 constant internal SCRIPT_START_LOCATION = 4;\n\n    /**\n    * @notice Executes script by delegatecall into a contract\n    * @param _script [ specId (uint32) ][ contract address (20 bytes) ]\n    * @param _input ABI encoded call to be made to contract (if empty executes default exec() function)\n    * @param _blacklist If any address is passed, will revert.\n    * @return Call return data\n    */\n    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n        require(_blacklist.length == 0); // dont have ability to control bans, so fail.\n\n        // Script should be spec id + address (20 bytes)\n        require(_script.length == SCRIPT_START_LOCATION + 20);\n        return delegate(_script.addressAt(SCRIPT_START_LOCATION), _input);\n    }\n\n    /**\n    * @dev Delegatecall to contract with input data\n    */\n    function delegate(address _addr, bytes memory _input) internal returns (bytes memory output) {\n        require(isContract(_addr));\n        require(_addr.delegatecall(_input.length > 0 ? _input : defaultInput()));\n        bytes memory ret = returnedData();\n\n        require(ret.length > 0);\n\n        return ret;\n    }\n\n    function defaultInput() internal pure returns (bytes) {\n        return DelegateScriptTarget(0).exec.selector.toBytes();\n    }\n\n    /**\n    * @dev copies and returns last's call data\n    */\n    function returnedData() internal pure returns (bytes ret) {\n        assembly {\n            let size := returndatasize\n            ret := mload(0x40) // free mem ptr get\n            mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n            mstore(ret, size) // set array length\n            returndatacopy(add(ret, 0x20), 0, size) // copy return data\n        }\n        return ret;\n    }\n}\n"
    },
    "@aragon/os/contracts/evmscript/executors/DeployDelegateScript.sol": {
      "keccak256": "0x9c454eac9c6c59a1341d112d170e4846071ca20952b25df3a0777871281e6262",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/evmscript/executors/DeployDelegateScript.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./DelegateScript.sol\";\n\n// Inspired by: https://github.com/dapphub/ds-proxy/blob/master/src/proxy.sol\n\n\ncontract DeployDelegateScript is DelegateScript {\n    uint256 constant internal SCRIPT_START_LOCATION = 4;\n\n    uint256[2**254] private cacheStorageOffset;\n    mapping (bytes32 => address) cache;\n\n    /**\n    * @notice Executes script by delegatecall into a deployed contract (exec() function)\n    * @param _script [ specId (uint32) ][ contractInitcode (bytecode) ]\n    * @param _input ABI encoded call to be made to contract (if empty executes default exec() function)\n    * @param _blacklist If any address is passed, will revert.\n    * @return Call return data\n    */\n    function execScript(bytes _script, bytes _input, address[] _blacklist) external returns (bytes) {\n        require(_blacklist.length == 0); // dont have ability to control bans, so fail.\n\n        bytes32 id = keccak256(_script);\n        address deployed = cache[id];\n        if (deployed == address(0)) {\n            deployed = deploy(_script);\n            cache[id] = deployed;\n        }\n\n        return DelegateScript.delegate(deployed, _input);\n    }\n\n    /**\n    * @dev Deploys contract byte code to network\n    */\n    function deploy(bytes _script) internal returns (address addr) {\n        assembly {\n            // 0x24 = 0x20 (length) + 0x04 (spec id uint32)\n            // Length of code is 4 bytes less than total script size\n            addr := create(0, add(_script, 0x24), sub(mload(_script), 0x04))\n            switch iszero(extcodesize(addr))\n            case 1 { revert(0, 0) } // throw if contract failed to deploy\n        }\n    }\n}\n"
    },
    "@aragon/os/contracts/factory/EVMScriptRegistryFactory.sol": {
      "keccak256": "0x12278bb0b28186839ee9d4382c63d664eade586709e747dfeb8d40ab6027032b",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/factory/EVMScriptRegistryFactory.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../evmscript/EVMScriptRegistry.sol\";\n\nimport \"../evmscript/executors/CallsScript.sol\";\nimport \"../evmscript/executors/DelegateScript.sol\";\nimport \"../evmscript/executors/DeployDelegateScript.sol\";\n\nimport \"./AppProxyFactory.sol\";\nimport \"../kernel/Kernel.sol\";\nimport \"../acl/ACL.sol\";\n\n\ncontract EVMScriptRegistryFactory is AppProxyFactory, EVMScriptRegistryConstants {\n    address public baseReg;\n    address public baseCalls;\n    address public baseDel;\n    address public baseDeployDel;\n\n    function EVMScriptRegistryFactory() public {\n        baseReg = address(new EVMScriptRegistry());\n        baseCalls = address(new CallsScript());\n        baseDel = address(new DelegateScript());\n        baseDeployDel = address(new DeployDelegateScript());\n    }\n\n    function newEVMScriptRegistry(Kernel _dao, address _root) public returns (EVMScriptRegistry reg) {\n        reg = EVMScriptRegistry(_dao.newPinnedAppInstance(EVMSCRIPT_REGISTRY_APP_ID, baseReg, true));\n        reg.initialize();\n\n        ACL acl = ACL(_dao.acl());\n\n        acl.createPermission(this, reg, reg.REGISTRY_MANAGER_ROLE(), this);\n\n        reg.addScriptExecutor(baseCalls);     // spec 1 = CallsScript\n        reg.addScriptExecutor(baseDel);       // spec 2 = DelegateScript\n        reg.addScriptExecutor(baseDeployDel); // spec 3 = DeployDelegateScript\n\n        acl.revokePermission(this, reg, reg.REGISTRY_MANAGER_ROLE());\n        acl.setPermissionManager(_root, reg, reg.REGISTRY_MANAGER_ROLE());\n\n        return reg;\n    }\n}\n"
    },
    "@aragon/os/contracts/factory/DAOFactory.sol": {
      "keccak256": "0x24eaf34f2a19158610a66454f33a7507e9e8e8b4bf6f26217e43a0a71995759a",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/factory/DAOFactory.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../kernel/Kernel.sol\";\nimport \"../kernel/KernelProxy.sol\";\n\nimport \"../acl/ACL.sol\";\n\nimport \"./EVMScriptRegistryFactory.sol\";\n\n\ncontract DAOFactory {\n    address public baseKernel;\n    address public baseACL;\n    EVMScriptRegistryFactory public regFactory;\n\n    event DeployDAO(address dao);\n    event DeployEVMScriptRegistry(address reg);\n\n    function DAOFactory(address _baseKernel, address _baseACL, address _regFactory) public {\n        // No need to init as it cannot be killed by devops199\n        if (_regFactory != address(0)) {\n            regFactory = EVMScriptRegistryFactory(_regFactory);\n        }\n\n        baseKernel = _baseKernel;\n        baseACL = _baseACL;\n    }\n\n    /**\n    * @param _root Address that will be granted control to setup DAO permissions\n    */\n    function newDAO(address _root) public returns (Kernel dao) {\n        dao = Kernel(new KernelProxy(baseKernel));\n\n        if (address(regFactory) == address(0)) {\n            dao.initialize(baseACL, _root);\n        } else {\n            dao.initialize(baseACL, this);\n\n            ACL acl = ACL(dao.acl());\n            bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n            bytes32 appManagerRole = dao.APP_MANAGER_ROLE();\n\n            acl.grantPermission(regFactory, acl, permRole);\n\n            acl.createPermission(regFactory, dao, appManagerRole, this);\n\n            EVMScriptRegistry reg = regFactory.newEVMScriptRegistry(dao, _root);\n            DeployEVMScriptRegistry(address(reg));\n\n            acl.revokePermission(regFactory, dao, appManagerRole);\n            acl.revokePermission(regFactory, acl, permRole);\n            acl.revokePermission(this, acl, permRole);\n            acl.grantPermission(_root, acl, permRole);\n\n            acl.removePermissionManager(dao, appManagerRole);\n            acl.setPermissionManager(_root, acl, permRole);\n        }\n\n        DeployDAO(dao);\n    }\n}\n"
    },
    "./contracts/LiquidPledgingACLHelpers.sol": {
      "keccak256": "0xb675a7a788bf656d4c3c78f3b4cf6645afb432939d1a4c38d70e01d068b0ce62",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LiquidPledgingACLHelpers.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\ncontract LiquidPledgingACLHelpers {\n    function arr(uint64 a, uint64 b, address c, uint d, address e) internal pure returns(uint[] r) {\n        r = new uint[](4);\n        r[0] = uint(a);\n        r[1] = uint(b);\n        r[2] = uint(c);\n        r[3] = d;\n        r[4] = uint(e);\n    }\n\n    function arr(bool a) internal pure returns (uint[] r) {\n        r = new uint[](1);\n        uint _a;\n        assembly {\n            _a := a // forced casting\n        }\n        r[0] = _a;\n    }\n}"
    },
    "./contracts/LPVault.sol": {
      "keccak256": "0x2cae6ff214175f87d073cf0c48e0906e9289dcec286a669dd8e69d8809b2052a",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LPVault.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina\n    Contributors: RJ Ewing, Griff Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// @dev This contract holds ether securely for liquid pledging systems; for\n///  this iteration the funds will come often be escaped to the Giveth Multisig\n///  (safety precaution), but once fully tested and optimized this contract will\n///  be a safe place to store funds equipped with optional variable time delays\n///  to allow for an optional escapeHatch to be implemented in case of issues;\n///  future versions of this contract will be enabled for tokens\nimport \"./LiquidPledgingACLHelpers.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\n/// @dev `LiquidPledging` is a basic interface to allow the `LPVault` contract\n///  to confirm and cancel payments in the `LiquidPledging` contract.\ncontract ILiquidPledging {\n    function confirmPayment(uint64 idPledge, uint amount) public;\n    function cancelPayment(uint64 idPledge, uint amount) public;\n}\n\n/// @dev `LPVault` is a higher level contract built off of the `Escapable`\n///  contract that holds funds for the liquid pledging system.\ncontract LPVault is AragonApp, LiquidPledgingACLHelpers {\n\n    bytes32 constant public CONFIRM_PAYMENT_ROLE = keccak256(\"CONFIRM_PAYMENT_ROLE\");\n    bytes32 constant public CANCEL_PAYMENT_ROLE = keccak256(\"CANCEL_PAYMENT_ROLE\");\n    bytes32 constant public SET_AUTOPAY_ROLE = keccak256(\"SET_AUTOPAY_ROLE\");\n    bytes32 constant public ESCAPE_HATCH_CALLER_ROLE = keccak256(\"ESCAPE_HATCH_CALLER_ROLE\");\n\n    event AutoPaySet(bool autoPay);\n    event EscapeFundsCalled(address token, uint amount);\n    event ConfirmPayment(uint indexed idPayment, bytes32 indexed ref);\n    event CancelPayment(uint indexed idPayment, bytes32 indexed ref);\n    event AuthorizePayment(\n        uint indexed idPayment,\n        bytes32 indexed ref,\n        address indexed dest,\n        address token,\n        uint amount\n    );\n\n    enum PaymentStatus {\n        Pending, // When the payment is awaiting confirmation\n        Paid,    // When the payment has been sent\n        Canceled // When the payment will never be sent\n    }\n\n    /// @dev `Payment` is a public structure that describes the details of\n    ///  each payment the `ref` param makes it easy to track the movements of\n    ///  funds transparently by its connection to other `Payment` structs\n    struct Payment {\n        bytes32 ref; // an input that references details from other contracts\n        address dest; // recipient of the ETH\n        PaymentStatus state; // Pending, Paid or Canceled\n        address token;\n        uint amount; // amount of ETH (in wei) to be sent\n    }\n\n    bool public autoPay; // If false, payments will take 2 txs to be completed\n\n    // @dev An array that contains all the payments for this LPVault\n    Payment[] public payments;\n    ILiquidPledging public liquidPledging;\n\n    /// @dev The attached `LiquidPledging` contract is the only address that can\n    ///  call a function with this modifier\n    modifier onlyLiquidPledging() {\n        require(msg.sender == address(liquidPledging));\n        _;\n    }\n\n    /// @param _liquidPledging Address of the liquidPledging instance associated\n    /// with this LPVault\n    function initialize(address _liquidPledging) onlyInit external {\n        require(_liquidPledging != 0x0);\n        initialized();\n\n        liquidPledging = ILiquidPledging(_liquidPledging);\n    }\n\n    /// @notice Used to decentralize, toggles whether the LPVault will\n    ///  automatically confirm a payment after the payment has been authorized\n    /// @param _automatic If true, payments will confirm instantly, if false\n    ///  the training wheels are put on and the owner must manually approve \n    ///  every payment\n    function setAutopay(bool _automatic) external authP(SET_AUTOPAY_ROLE, arr(_automatic)) {\n        autoPay = _automatic;\n        AutoPaySet(autoPay);\n    }\n\n    /// @notice If `autoPay == true` the transfer happens automatically `else` the `owner`\n    ///  must call `confirmPayment()` for a transfer to occur (training wheels);\n    ///  either way, a new payment is added to `payments[]` \n    /// @param _ref References the payment will normally be the pledgeID\n    /// @param _dest The address that payments will be sent to\n    /// @param _amount The amount that the payment is being authorized for\n    /// @return idPayment The id of the payment (needed by the owner to confirm)\n    function authorizePayment(\n        bytes32 _ref,\n        address _dest,\n        address _token,\n        uint _amount\n    ) external onlyLiquidPledging returns (uint)\n    {\n        uint idPayment = payments.length;\n        payments.length ++;\n        payments[idPayment].state = PaymentStatus.Pending;\n        payments[idPayment].ref = _ref;\n        payments[idPayment].dest = _dest;\n        payments[idPayment].token = _token;\n        payments[idPayment].amount = _amount;\n\n        AuthorizePayment(idPayment, _ref, _dest, _token, _amount);\n\n        if (autoPay) {\n            _doConfirmPayment(idPayment);\n        }\n\n        return idPayment;\n    }\n\n    /// @notice Allows the owner to confirm payments;  since \n    ///  `authorizePayment` is the only way to populate the `payments[]` array\n    ///  this is generally used when `autopay` is `false` after a payment has\n    ///  has been authorized\n    /// @param _idPayment Array lookup for the payment.\n    function confirmPayment(uint _idPayment) public {\n        Payment storage p = payments[_idPayment];\n        require(canPerform(msg.sender, CONFIRM_PAYMENT_ROLE, arr(_idPayment, p.amount)));\n        _doConfirmPayment(_idPayment);\n    }\n\n    /// @notice When `autopay` is `false` and after a payment has been authorized\n    ///  to allow the owner to cancel a payment instead of confirming it.\n    /// @param _idPayment Array lookup for the payment.\n    function cancelPayment(uint _idPayment) external {\n        _doCancelPayment(_idPayment);\n    }\n\n    /// @notice `onlyOwner` An efficient way to confirm multiple payments\n    /// @param _idPayments An array of multiple payment ids\n    function multiConfirm(uint[] _idPayments) external {\n        for (uint i = 0; i < _idPayments.length; i++) {\n            confirmPayment(_idPayments[i]);\n        }\n    }\n\n    /// @notice `onlyOwner` An efficient way to cancel multiple payments\n    /// @param _idPayments An array of multiple payment ids\n    function multiCancel(uint[] _idPayments) external {\n        for (uint i = 0; i < _idPayments.length; i++) {\n            _doCancelPayment(_idPayments[i]);\n        }\n    }\n\n    /**\n    * @dev By default, AragonApp will allow anyone to call transferToVault\n    *      Because this app is designed to hold funds, we only want to call\n    *      transferToVault in the case of an emergency. Only senders with the\n    *      ESCAPE_HATCH_CALLER_ROLE are allowed to pull the \"escapeHatch\"\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return canPerform(msg.sender, ESCAPE_HATCH_CALLER_ROLE, arr(token));\n    }\n\n    /// @return The total number of payments that have ever been authorized\n    function nPayments() external view returns (uint) {\n        return payments.length;\n    }\n\n    /// @notice Transfers ETH according to the data held within the specified\n    ///  payment id (internal function)\n    /// @param _idPayment id number for the payment about to be fulfilled \n    function _doConfirmPayment(uint _idPayment) internal {\n        require(_idPayment < payments.length);\n        Payment storage p = payments[_idPayment];\n        require(p.state == PaymentStatus.Pending);\n\n        p.state = PaymentStatus.Paid;\n        liquidPledging.confirmPayment(uint64(p.ref), p.amount);\n\n        // transfer token or eth\n        if (p.token == ETH) {\n            require(this.balance >= p.amount);\n            p.dest.transfer(p.amount);  // Transfers ETH denominated in wei\n        } else {\n            ERC20 token = ERC20(p.token);\n            require(token.transfer(p.dest, p.amount)); // Transfers token to dest            \n        }\n\n\n        ConfirmPayment(_idPayment, p.ref);\n    }\n\n    /// @notice Cancels a pending payment (internal function)\n    /// @param _idPayment id number for the payment    \n    function _doCancelPayment(uint _idPayment) internal authP(CANCEL_PAYMENT_ROLE, arr(_idPayment)) {\n        require(_idPayment < payments.length);\n        Payment storage p = payments[_idPayment];\n        require(p.state == PaymentStatus.Pending);\n\n        p.state = PaymentStatus.Canceled;\n\n        liquidPledging.cancelPayment(uint64(p.ref), p.amount);\n\n        CancelPayment(_idPayment, p.ref);\n    }\n\n    /// @dev The fall back function allows ETH to be deposited into the LPVault\n    ///  through a simple send\n    function () public payable {}    \n}\n"
    },
    "./contracts/LiquidPledgingStorage.sol": {
      "keccak256": "0xd1f287f7471c80d4167f47a462930d83208c366f3858eb8b2e6dc923382a5f08",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LiquidPledgingStorage.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./ILiquidPledgingPlugin.sol\";\n\n/// @dev This is an interface for `LPVault` which serves as a secure storage for\n///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes\n///  payments can Pledges be converted for ETH\ninterface ILPVault {\n    function authorizePayment(bytes32 _ref, address _dest, address _token, uint _amount) public;\n    function () public payable;\n}\n\n/// This contract contains all state variables used in LiquidPledging contracts\n/// This is done to have everything in 1 location, b/c state variable layout\n/// is MUST have be the same when performing an upgrade.\ncontract LiquidPledgingStorage {\n    enum PledgeAdminType { Giver, Delegate, Project }\n    enum PledgeState { Pledged, Paying, Paid }\n\n    /// @dev This struct defines the details of a `PledgeAdmin` which are \n    ///  commonly referenced by their index in the `admins` array\n    ///  and can own pledges and act as delegates\n    struct PledgeAdmin { \n        PledgeAdminType adminType; // Giver, Delegate or Project\n        address addr; // Account or contract address for admin\n        uint64 commitTime;  // In seconds, used for time Givers' & Delegates' have to veto\n        uint64 parentProject;  // Only for projects\n        bool canceled;      //Always false except for canceled projects\n\n        /// @dev if the plugin is 0x0 then nothing happens, if its an address\n        // than that smart contract is called when appropriate\n        ILiquidPledgingPlugin plugin; \n        string name;\n        string url;  // Can be IPFS hash\n    }\n\n    struct Pledge {\n        uint amount;\n        uint64[] delegationChain; // List of delegates in order of authority\n        uint64 owner; // PledgeAdmin\n        uint64 intendedProject; // Used when delegates are sending to projects\n        uint64 commitTime;  // When the intendedProject will become the owner\n        uint64 oldPledge; // Points to the id that this Pledge was derived from\n        address token;\n        PledgeState pledgeState; //  Pledged, Paying, Paid\n    }\n\n    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin\n    Pledge[] pledges;\n    /// @dev this mapping allows you to search for a specific pledge's \n    ///  index number by the hash of that pledge\n    mapping (bytes32 => uint64) hPledge2idx;\n\n    // this whitelist is for non-proxied plugins\n    mapping (bytes32 => bool) pluginContractWhitelist;\n    // this whitelist is for proxied plugins\n    mapping (address => bool) pluginInstanceWhitelist;\n    bool public whitelistDisabled = false;\n\n    ILPVault public vault;\n\n    // reserve 50 slots for future upgrades.\n    uint[50] private storageOffset;\n}"
    },
    "./contracts/LiquidPledgingPlugins.sol": {
      "keccak256": "0x109373f81759324d3d39f0b2b8fd02072c2b0e502901c14e1b06ca91a05a5ae2",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LiquidPledgingPlugins.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"./LiquidPledgingStorage.sol\";\nimport \"./LiquidPledgingACLHelpers.sol\";\n\ncontract LiquidPledgingPlugins is AragonApp, LiquidPledgingStorage, LiquidPledgingACLHelpers {\n\n    bytes32 constant public PLUGIN_MANAGER_ROLE = keccak256(\"PLUGIN_MANAGER_ROLE\");\n\n    /**\n    * @dev adds an instance of a plugin to the whitelist\n    */\n    function addValidPluginInstance(address addr) auth(PLUGIN_MANAGER_ROLE) external {\n        pluginInstanceWhitelist[addr] = true;\n    }\n\n    /**\n    * @dev add a contract to the plugin whitelist.\n    * @notice Proxy contracts should never be added using this method. Each individual\n    *         proxy instance should be added by calling `addValidPluginInstance`\n    */\n    function addValidPluginContract(bytes32 contractHash) auth(PLUGIN_MANAGER_ROLE) public {\n        pluginContractWhitelist[contractHash] = true;\n    }\n\n    function addValidPluginContracts(bytes32[] contractHashes) external auth(PLUGIN_MANAGER_ROLE) {\n        for (uint8 i = 0; i < contractHashes.length; i++) {\n            addValidPluginContract(contractHashes[i]);\n        }\n    }\n\n    /**\n    * @dev removes a contract from the plugin whitelist\n    */\n    function removeValidPluginContract(bytes32 contractHash) external authP(PLUGIN_MANAGER_ROLE, arr(contractHash)) {\n        pluginContractWhitelist[contractHash] = false;\n    }\n\n    /**\n    * @dev removes an instance of a plugin to the whitelist\n    */\n    function removeValidPluginInstance(address addr) external authP(PLUGIN_MANAGER_ROLE, arr(addr)) {\n        pluginInstanceWhitelist[addr] = false;\n    }\n\n    /**\n    * @dev enable/disable the plugin whitelist.\n    * @notice you better know what you're doing if you are going to disable it\n    */\n    function useWhitelist(bool useWhitelist) external auth(PLUGIN_MANAGER_ROLE) {\n        whitelistDisabled = !useWhitelist;\n    }\n\n    /**\n    * check if the contract at the provided address is in the plugin whitelist\n    */\n    function isValidPlugin(address addr) public view returns(bool) {\n        if (whitelistDisabled || addr == 0x0) {\n            return true;\n        }\n\n        // first check pluginInstances\n        if (pluginInstanceWhitelist[addr]) {\n            return true;\n        }\n\n        // if the addr isn't a valid instance, check the contract code\n        bytes32 contractHash = getCodeHash(addr);\n\n        return pluginContractWhitelist[contractHash];\n    }\n\n    /**\n    * @return the hash of the code for the given address\n    */\n    function getCodeHash(address addr) public view returns(bytes32) {\n        bytes memory o_code;\n        assembly {\n            // retrieve the size of the code\n            let size := extcodesize(addr)\n            // allocate output byte array\n            o_code := mload(0x40)\n            mstore(o_code, size) // store length in memory\n            // actually retrieve the code\n            extcodecopy(addr, add(o_code, 0x20), 0, size)\n        }\n        return keccak256(o_code);\n    }\n}"
    },
    "./contracts/PledgeAdmins.sol": {
      "keccak256": "0x06bc6171a12d31aaa05dce4217e107555f8289182046a0bd8da615c38faae3f5",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/PledgeAdmins.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport \"./LiquidPledgingPlugins.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\ncontract PledgeAdmins is AragonApp, LiquidPledgingPlugins {\n\n    // Limits inserted to prevent large loops that could prevent canceling\n    uint constant MAX_SUBPROJECT_LEVEL = 20;\n    uint constant MAX_INTERPROJECT_LEVEL = 20;\n\n    // Events\n    event GiverAdded(uint64 indexed idGiver, string url);\n    event GiverUpdated(uint64 indexed idGiver, string url);\n    event DelegateAdded(uint64 indexed idDelegate, string url);\n    event DelegateUpdated(uint64 indexed idDelegate, string url);\n    event ProjectAdded(uint64 indexed idProject, string url);\n    event ProjectUpdated(uint64 indexed idProject, string url);\n\n////////////////////\n// Public functions\n////////////////////\n\n    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address\n    /// @param name The name used to identify the Giver\n    /// @param url The link to the Giver's profile often an IPFS hash\n    /// @param commitTime The length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    /// @param plugin This is Giver's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idGiver The id number used to reference this Admin\n    function addGiver(\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idGiver)\n    {\n        return addGiver(\n            msg.sender,\n            name,\n            url,\n            commitTime,\n            plugin\n        );\n    }\n\n    function addGiver(\n        address addr,\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) public returns (uint64 idGiver)\n    {\n        require(isValidPlugin(plugin)); // Plugin check\n\n        idGiver = uint64(admins.length);\n\n        // Save the fields\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Giver,\n                addr,\n                commitTime,\n                0,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        GiverAdded(idGiver, url);\n    }\n\n    /// @notice Updates a Giver's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\n    ///  by the current address of the Giver\n    /// @param idGiver This is the Admin id number used to specify the Giver\n    /// @param newAddr The new address that represents this Giver\n    /// @param newName The new name used to identify the Giver\n    /// @param newUrl The new link to the Giver's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    function updateGiver(\n        uint64 idGiver,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage giver = _findAdmin(idGiver);\n        require(msg.sender == giver.addr);\n        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver\n        giver.addr = newAddr;\n        giver.name = newName;\n        giver.url = newUrl;\n        giver.commitTime = newCommitTime;\n\n        GiverUpdated(idGiver, newUrl);\n    }\n\n    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr\n    /// @param name The name used to identify the Delegate\n    /// @param url The link to the Delegate's profile often an IPFS hash\n    /// @param commitTime Sets the length of time in seconds that this delegate\n    ///  can be vetoed. Whenever this delegate is in a delegate chain the time\n    ///  allowed to veto any event must be greater than or equal to this time.\n    /// @param plugin This is Delegate's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idxDelegate The id number used to reference this Delegate within\n    ///  the PLEDGE_ADMIN array\n    function addDelegate(\n        string name,\n        string url,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idDelegate) \n    {\n        require(isValidPlugin(plugin)); // Plugin check\n\n        idDelegate = uint64(admins.length);\n\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Delegate,\n                msg.sender,\n                commitTime,\n                0,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        DelegateAdded(idDelegate, url);\n    }\n\n    /// @notice Updates a Delegate's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin, and it must be called\n    ///  by the current address of the Delegate\n    /// @param idDelegate The Admin id number used to specify the Delegate\n    /// @param newAddr The new address that represents this Delegate\n    /// @param newName The new name used to identify the Delegate\n    /// @param newUrl The new link to the Delegate's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds that this\n    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain\n    ///  the time allowed to veto any event must be greater than or equal to\n    ///  this time.\n    function updateDelegate(\n        uint64 idDelegate,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage delegate = _findAdmin(idDelegate);\n        require(msg.sender == delegate.addr);\n        require(delegate.adminType == PledgeAdminType.Delegate);\n        delegate.addr = newAddr;\n        delegate.name = newName;\n        delegate.url = newUrl;\n        delegate.commitTime = newCommitTime;\n\n        DelegateUpdated(idDelegate, newUrl);\n    }\n\n    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr\n    /// @param name The name used to identify the Project\n    /// @param url The link to the Project's profile often an IPFS hash\n    /// @param projectAdmin The address for the trusted project manager\n    /// @param parentProject The Admin id number for the parent project or 0 if\n    ///  there is no parentProject\n    /// @param commitTime Sets the length of time in seconds the Project has to\n    ///   veto when the Project delegates to another Delegate and they pledge\n    ///   those funds to a project\n    /// @param plugin This is Project's liquid pledge plugin allowing for\n    ///  extended functionality\n    /// @return idProject The id number used to reference this Admin\n    function addProject(\n        string name,\n        string url,\n        address projectAdmin,\n        uint64 parentProject,\n        uint64 commitTime,\n        ILiquidPledgingPlugin plugin\n    ) external returns (uint64 idProject) \n    {\n        require(isValidPlugin(plugin));\n\n        if (parentProject != 0) {\n            PledgeAdmin storage a = _findAdmin(parentProject);\n            // getProjectLevel will check that parentProject has a `Project` adminType\n            require(_getProjectLevel(a) < MAX_SUBPROJECT_LEVEL);\n        }\n\n        idProject = uint64(admins.length);\n\n        admins.push(\n            PledgeAdmin(\n                PledgeAdminType.Project,\n                projectAdmin,\n                commitTime,\n                parentProject,\n                false,\n                plugin,\n                name,\n                url)\n        );\n\n        ProjectAdded(idProject, url);\n    }\n\n    /// @notice Updates a Project's info to change the address, name, url, or\n    ///  commitTime, it cannot be used to change a plugin or a parentProject,\n    ///  and it must be called by the current address of the Project\n    /// @param idProject The Admin id number used to specify the Project\n    /// @param newAddr The new address that represents this Project\n    /// @param newName The new name used to identify the Project\n    /// @param newUrl The new link to the Project's profile often an IPFS hash\n    /// @param newCommitTime Sets the length of time in seconds the Project has\n    ///  to veto when the Project delegates to a Delegate and they pledge those\n    ///  funds to a project\n    function updateProject(\n        uint64 idProject,\n        address newAddr,\n        string newName,\n        string newUrl,\n        uint64 newCommitTime\n    ) external \n    {\n        PledgeAdmin storage project = _findAdmin(idProject);\n\n        require(msg.sender == project.addr);\n        require(project.adminType == PledgeAdminType.Project);\n\n        project.addr = newAddr;\n        project.name = newName;\n        project.url = newUrl;\n        project.commitTime = newCommitTime;\n\n        ProjectUpdated(idProject, newUrl);\n    }\n\n/////////////////////////////\n// Public constant functions\n/////////////////////////////\n\n    /// @notice A constant getter used to check how many total Admins exist\n    /// @return The total number of admins (Givers, Delegates and Projects) .\n    function numberOfPledgeAdmins() external view returns(uint) {\n        return admins.length - 1;\n    }\n\n    /// @notice A constant getter to check the details of a specified Admin\n    /// @return addr Account or contract address for admin\n    /// @return name Name of the pledgeAdmin\n    /// @return url The link to the Project's profile often an IPFS hash\n    /// @return commitTime The length of time in seconds the Admin has to veto\n    ///   when the Admin delegates to a Delegate and that Delegate pledges those\n    ///   funds to a project\n    /// @return parentProject The Admin id number for the parent project or 0\n    ///  if there is no parentProject\n    /// @return canceled 0 for Delegates & Givers, true if a Project has been\n    ///  canceled\n    /// @return plugin This is Project's liquidPledging plugin allowing for\n    ///  extended functionality\n    function getPledgeAdmin(uint64 idAdmin) external view returns (\n        PledgeAdminType adminType,\n        address addr,\n        string name,\n        string url,\n        uint64 commitTime,\n        uint64 parentProject,\n        bool canceled,\n        address plugin\n    ) {\n        PledgeAdmin storage a = _findAdmin(idAdmin);\n        adminType = a.adminType;\n        addr = a.addr;\n        name = a.name;\n        url = a.url;\n        commitTime = a.commitTime;\n        parentProject = a.parentProject;\n        canceled = a.canceled;\n        plugin = address(a.plugin);\n    }\n\n    /// @notice A getter to find if a specified Project has been canceled\n    /// @param projectId The Admin id number used to specify the Project\n    /// @return True if the Project has been canceled\n    function isProjectCanceled(uint64 projectId)\n        public view returns (bool)\n    {\n        PledgeAdmin storage a = _findAdmin(projectId);\n\n        if (a.adminType == PledgeAdminType.Giver) {\n            return false;\n        }\n\n        assert(a.adminType == PledgeAdminType.Project);\n\n        if (a.canceled) {\n            return true;\n        }\n        if (a.parentProject == 0) {\n            return false;\n        }\n\n        return isProjectCanceled(a.parentProject);\n    }\n\n///////////////////\n// Internal methods\n///////////////////\n\n    /// @notice A getter to look up a Admin's details\n    /// @param idAdmin The id for the Admin to lookup\n    /// @return The PledgeAdmin struct for the specified Admin\n    function _findAdmin(uint64 idAdmin) internal view returns (PledgeAdmin storage) {\n        require(idAdmin < admins.length);\n        return admins[idAdmin];\n    }\n\n    /// @notice Find the level of authority a specific Project has\n    ///  using a recursive loop\n    /// @param a The project admin being queried\n    /// @return The level of authority a specific Project has\n    function _getProjectLevel(PledgeAdmin a) internal view returns(uint64) {\n        assert(a.adminType == PledgeAdminType.Project);\n\n        if (a.parentProject == 0) {\n            return(1);\n        }\n\n        PledgeAdmin storage parent = _findAdmin(a.parentProject);\n        return _getProjectLevel(parent) + 1;\n    }\n}"
    },
    "./contracts/Pledges.sol": {
      "keccak256": "0x9c7a60dff92f94d518d0c4a40d5434cd23680f79fd364ae855575ae4ca683797",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/Pledges.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n                  Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"./LiquidPledgingStorage.sol\";\n\ncontract Pledges is AragonApp, LiquidPledgingStorage {\n\n    // Limits inserted to prevent large loops that could prevent canceling\n    uint constant MAX_DELEGATES = 10;\n\n    // a constant for when a delegate is requested that is not in the system\n    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;\n\n/////////////////////////////\n// Public constant functions\n////////////////////////////\n\n    /// @notice A constant getter that returns the total number of pledges\n    /// @return The total number of Pledges in the system\n    function numberOfPledges() external view returns (uint) {\n        return pledges.length - 1;\n    }\n\n    /// @notice A getter that returns the details of the specified pledge\n    /// @param idPledge the id number of the pledge being queried\n    /// @return the amount, owner, the number of delegates (but not the actual\n    ///  delegates, the intendedProject (if any), the current commit time and\n    ///  the previous pledge this pledge was derived from\n    function getPledge(uint64 idPledge) external view returns(\n        uint amount,\n        uint64 owner,\n        uint64 nDelegates,\n        uint64 intendedProject,\n        uint64 commitTime,\n        uint64 oldPledge,\n        address token,\n        PledgeState pledgeState\n    ) {\n        Pledge memory p = _findPledge(idPledge);\n        amount = p.amount;\n        owner = p.owner;\n        nDelegates = uint64(p.delegationChain.length);\n        intendedProject = p.intendedProject;\n        commitTime = p.commitTime;\n        oldPledge = p.oldPledge;\n        token = p.token;\n        pledgeState = p.pledgeState;\n    }\n\n\n////////////////////\n// Internal methods\n////////////////////\n\n    /// @notice This creates a Pledge with an initial amount of 0 if one is not\n    ///  created already; otherwise it finds the pledge with the specified\n    ///  attributes; all pledges technically exist, if the pledge hasn't been\n    ///  created in this system yet it simply isn't in the hash array\n    ///  hPledge2idx[] yet\n    /// @param owner The owner of the pledge being looked up\n    /// @param delegationChain The list of delegates in order of authority\n    /// @param intendedProject The project this pledge will Fund after the\n    ///  commitTime has passed\n    /// @param commitTime The length of time in seconds the Giver has to\n    ///   veto when the Giver's delegates Pledge funds to a project\n    /// @param oldPledge This value is used to store the pledge the current\n    ///  pledge was came from, and in the case a Project is canceled, the Pledge\n    ///  will revert back to it's previous state\n    /// @param state The pledge state: Pledged, Paying, or state\n    /// @return The hPledge2idx index number\n    function _findOrCreatePledge(\n        uint64 owner,\n        uint64[] delegationChain,\n        uint64 intendedProject,\n        uint64 commitTime,\n        uint64 oldPledge,\n        address token,\n        PledgeState state\n    ) internal returns (uint64)\n    {\n        bytes32 hPledge = keccak256(delegationChain, owner, intendedProject, commitTime, oldPledge, token, state);\n        uint64 id = hPledge2idx[hPledge];\n        if (id > 0) {\n            return id;\n        }\n\n        id = uint64(pledges.length);\n        hPledge2idx[hPledge] = id;\n        pledges.push(\n            Pledge(\n                0,\n                delegationChain,\n                owner,\n                intendedProject,\n                commitTime,\n                oldPledge,\n                token,\n                state\n            )\n        );\n        return id;\n    }\n\n    /// @param idPledge the id of the pledge to load from storage\n    /// @return The Pledge\n    function _findPledge(uint64 idPledge) internal view returns(Pledge storage) {\n        require(idPledge < pledges.length);\n        return pledges[idPledge];\n    }\n\n    /// @notice A getter that searches the delegationChain for the level of\n    ///  authority a specific delegate has within a Pledge\n    /// @param p The Pledge that will be searched\n    /// @param idDelegate The specified delegate that's searched for\n    /// @return If the delegate chain contains the delegate with the\n    ///  `admins` array index `idDelegate` this returns that delegates\n    ///  corresponding index in the delegationChain. Otherwise it returns\n    ///  the NOTFOUND constant\n    function _getDelegateIdx(Pledge p, uint64 idDelegate) internal pure returns(uint64) {\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            if (p.delegationChain[i] == idDelegate) {\n                return uint64(i);\n            }\n        }\n        return NOTFOUND;\n    }\n\n    /// @notice A getter to find how many old \"parent\" pledges a specific Pledge\n    ///  had using a self-referential loop\n    /// @param p The Pledge being queried\n    /// @return The number of old \"parent\" pledges a specific Pledge had\n    function _getPledgeLevel(Pledge p) internal view returns(uint) {\n        if (p.oldPledge == 0) {\n            return 0;\n        }\n        Pledge storage oldP = _findPledge(p.oldPledge);\n        return _getPledgeLevel(oldP) + 1; // a loop lookup\n    }\n}\n"
    },
    "./contracts/LiquidPledgingBase.sol": {
      "keccak256": "0xbd10aeb8cd8834c63bb58034f93ed213ee8ed4f38682cc3808bdf1f5c7d79df3",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LiquidPledgingBase.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina\n    Contributors: Adri√† Massanet <adria@codecontext.io>, RJ Ewing, Griff\n    Green, Arthur Lunn\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledgingStorage.sol\";\nimport \"./PledgeAdmins.sol\";\nimport \"./Pledges.sol\";\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\n\n/// @dev `LiquidPledgingBase` is the base level contract used to carry out\n///  liquidPledging's most basic functions, mostly handling and searching the\n///  data structures\ncontract LiquidPledgingBase is AragonApp, LiquidPledgingStorage, PledgeAdmins, Pledges {\n\n    event Transfer(uint indexed from, uint indexed to, uint amount);\n    event CancelProject(uint indexed idProject);\n\n/////////////\n// Modifiers\n/////////////\n\n    /// @dev The `vault`is the only addresses that can call a function with this\n    ///  modifier\n    modifier onlyVault() {\n        require(msg.sender == address(vault));\n        _;\n    }\n\n///////////////\n// Constructor\n///////////////\n\n    /// @param _vault The vault where the ETH backing the pledges is stored\n    function initialize(address _vault) onlyInit public {\n        require(_vault != 0x0);\n        initialized();\n\n        vault = ILPVault(_vault);\n\n        admins.length = 1; // we reserve the 0 admin\n        pledges.length = 1; // we reserve the 0 pledge\n    }\n\n\n/////////////////////////////\n// Public constant functions\n/////////////////////////////\n\n    /// @notice Getter to find Delegate w/ the Pledge ID & the Delegate index\n    /// @param idPledge The id number representing the pledge being queried\n    /// @param idxDelegate The index number for the delegate in this Pledge \n    function getPledgeDelegate(uint64 idPledge, uint64 idxDelegate) external view returns(\n        uint64 idDelegate,\n        address addr,\n        string name\n    ) {\n        Pledge storage p = _findPledge(idPledge);\n        idDelegate = p.delegationChain[idxDelegate - 1];\n        PledgeAdmin storage delegate = _findAdmin(idDelegate);\n        addr = delegate.addr;\n        name = delegate.name;\n    }\n\n///////////////////\n// Public functions\n///////////////////\n\n    /// @notice Only affects pledges with the Pledged PledgeState for 2 things:\n    ///   #1: Checks if the pledge should be committed. This means that\n    ///       if the pledge has an intendedProject and it is past the\n    ///       commitTime, it changes the owner to be the proposed project\n    ///       (The UI will have to read the commit time and manually do what\n    ///       this function does to the pledge for the end user\n    ///       at the expiration of the commitTime)\n    ///\n    ///   #2: Checks to make sure that if there has been a cancellation in the\n    ///       chain of projects, the pledge's owner has been changed\n    ///       appropriately.\n    ///\n    /// This function can be called by anybody at anytime on any pledge.\n    ///  In general it can be called to force the calls of the affected \n    ///  plugins, which also need to be predicted by the UI\n    /// @param idPledge This is the id of the pledge that will be normalized\n    /// @return The normalized Pledge!\n    function normalizePledge(uint64 idPledge) public returns(uint64) {\n        Pledge storage p = _findPledge(idPledge);\n\n        // Check to make sure this pledge hasn't already been used \n        // or is in the process of being used\n        if (p.pledgeState != PledgeState.Pledged) {\n            return idPledge;\n        }\n\n        // First send to a project if it's proposed and committed\n        if ((p.intendedProject > 0) && ( _getTime() > p.commitTime)) {\n            uint64 oldPledge = _findOrCreatePledge(\n                p.owner,\n                p.delegationChain,\n                0,\n                0,\n                p.oldPledge,\n                p.token,\n                PledgeState.Pledged\n            );\n            uint64 toPledge = _findOrCreatePledge(\n                p.intendedProject,\n                new uint64[](0),\n                0,\n                0,\n                oldPledge,\n                p.token,\n                PledgeState.Pledged\n            );\n            _doTransfer(idPledge, toPledge, p.amount);\n            idPledge = toPledge;\n            p = _findPledge(idPledge);\n        }\n\n        toPledge = _getOldestPledgeNotCanceled(idPledge);\n        if (toPledge != idPledge) {\n            _doTransfer(idPledge, toPledge, p.amount);\n        }\n\n        return toPledge;\n    }\n\n////////////////////\n// Internal methods\n////////////////////\n\n    /// @notice A check to see if the msg.sender is the owner or the\n    ///  plugin contract for a specific Admin\n    /// @param idAdmin The id of the admin being checked\n    function _checkAdminOwner(uint64 idAdmin) internal view {\n        PledgeAdmin storage a = _findAdmin(idAdmin);\n        require(msg.sender == address(a.plugin) || msg.sender == a.addr);\n    }\n\n    function _transfer( \n        uint64 idSender,\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal\n    {\n        require(idReceiver > 0); // prevent burning value\n        idPledge = normalizePledge(idPledge);\n\n        Pledge storage p = _findPledge(idPledge);\n        PledgeAdmin storage receiver = _findAdmin(idReceiver);\n\n        require(p.pledgeState == PledgeState.Pledged);\n\n        // If the sender is the owner of the Pledge\n        if (p.owner == idSender) {\n\n            if (receiver.adminType == PledgeAdminType.Giver) {\n                _transferOwnershipToGiver(idPledge, amount, idReceiver);\n                return;\n            } else if (receiver.adminType == PledgeAdminType.Project) {\n                _transferOwnershipToProject(idPledge, amount, idReceiver);\n                return;\n            } else if (receiver.adminType == PledgeAdminType.Delegate) {\n\n                uint recieverDIdx = _getDelegateIdx(p, idReceiver);\n                if (p.intendedProject > 0 && recieverDIdx != NOTFOUND) {\n                    // if there is an intendedProject and the receiver is in the delegationChain,\n                    // then we want to preserve the delegationChain as this is a veto of the\n                    // intendedProject by the owner\n\n                    if (recieverDIdx == p.delegationChain.length - 1) {\n                        uint64 toPledge = _findOrCreatePledge(\n                            p.owner,\n                            p.delegationChain,\n                            0,\n                            0,\n                            p.oldPledge,\n                            p.token,\n                            PledgeState.Pledged);\n                        _doTransfer(idPledge, toPledge, amount);\n                        return;\n                    }\n\n                    _undelegate(idPledge, amount, p.delegationChain.length - receiverDIdx - 1);\n                    return;\n                }\n                // owner is not vetoing an intendedProject and is transferring the pledge to a delegate,\n                // so we want to reset the delegationChain\n                idPledge = _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length\n                );\n                _appendDelegate(idPledge, amount, idReceiver);\n                return;\n            }\n\n            // This should never be reached as the receiver.adminType\n            // should always be either a Giver, Project, or Delegate\n            assert(false);\n        }\n\n        // If the sender is a Delegate\n        uint senderDIdx = _getDelegateIdx(p, idSender);\n        if (senderDIdx != NOTFOUND) {\n\n            // And the receiver is another Giver\n            if (receiver.adminType == PledgeAdminType.Giver) {\n                // Only transfer to the Giver who owns the pledge\n                assert(p.owner == idReceiver);\n                _undelegate(idPledge, amount, p.delegationChain.length);\n                return;\n            }\n\n            // And the receiver is another Delegate\n            if (receiver.adminType == PledgeAdminType.Delegate) {\n                uint receiverDIdx = _getDelegateIdx(p, idReceiver);\n\n                // And not in the delegationChain or part of the delegationChain\n                // is after the sender, then all of the other delegates after \n                // the sender are removed and the receiver is appended at the \n                // end of the delegationChain\n                if (receiverDIdx == NOTFOUND || receiverDIdx > senderDIdx) {\n                    idPledge = _undelegate(\n                        idPledge,\n                        amount,\n                        p.delegationChain.length - senderDIdx - 1\n                    );\n                    _appendDelegate(idPledge, amount, idReceiver);\n                    return;\n                }\n\n                // And is already part of the delegate chain but is before the\n                //  sender, then the sender and all of the other delegates after\n                //  the RECEIVER are removed from the delegationChain\n                _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length - receiverDIdx - 1\n                );\n                return;\n            }\n\n            // And the receiver is a Project, all the delegates after the sender\n            //  are removed and the amount is pre-committed to the project\n            if (receiver.adminType == PledgeAdminType.Project) {\n                idPledge = _undelegate(\n                    idPledge,\n                    amount,\n                    p.delegationChain.length - senderDIdx - 1\n                );\n                _proposeAssignProject(idPledge, amount, idReceiver);\n                return;\n            }\n        }\n        assert(false);  // When the sender is not an owner or a delegate\n    }\n\n    /// @notice `transferOwnershipToProject` allows for the transfer of\n    ///  ownership to the project, but it can also be called by a project\n    ///  to un-delegate everyone by setting one's own id for the idReceiver\n    /// @param idPledge the id of the pledge to be transfered.\n    /// @param amount Quantity of value that's being transfered\n    /// @param idReceiver The new owner of the project (or self to un-delegate)\n    function _transferOwnershipToProject(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        // Ensure that the pledge is not already at max pledge depth\n        // and the project has not been canceled\n        require(_getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n        require(!isProjectCanceled(idReceiver));\n\n        uint64 oldPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        uint64 toPledge = _findOrCreatePledge(\n            idReceiver,                     // Set the new owner\n            new uint64[](0),                // clear the delegation chain\n            0,\n            0,\n            oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }   \n\n\n    /// @notice `transferOwnershipToGiver` allows for the transfer of\n    ///  value back to the Giver, value is placed in a pledged state\n    ///  without being attached to a project, delegation chain, or time line.\n    /// @param idPledge the id of the pledge to be transferred.\n    /// @param amount Quantity of value that's being transferred\n    /// @param idReceiver The new owner of the pledge\n    function _transferOwnershipToGiver(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        uint64 toPledge = _findOrCreatePledge(\n            idReceiver,\n            new uint64[](0),\n            0,\n            0,\n            0,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\n    ///  end of the delegate chain for a given Pledge.\n    /// @param idPledge the id of the pledge thats delegate chain will be modified.\n    /// @param amount Quantity of value that's being chained.\n    /// @param idReceiver The delegate to be added at the end of the chain\n    function _appendDelegate(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.delegationChain.length < MAX_DELEGATES);\n        uint64[] memory newDelegationChain = new uint64[](\n            p.delegationChain.length + 1\n        );\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            newDelegationChain[i] = p.delegationChain[i];\n        }\n\n        // Make the last item in the array the idReceiver\n        newDelegationChain[p.delegationChain.length] = idReceiver;\n\n        uint64 toPledge = _findOrCreatePledge(\n            p.owner,\n            newDelegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `appendDelegate` allows for a delegate to be added onto the\n    ///  end of the delegate chain for a given Pledge.\n    /// @param idPledge the id of the pledge thats delegate chain will be modified.\n    /// @param amount Quantity of value that's shifted from delegates.\n    /// @param q Number (or depth) of delegates to remove\n    /// @return toPledge The id for the pledge being adjusted or created\n    function _undelegate(\n        uint64 idPledge,\n        uint amount,\n        uint q\n    ) internal returns (uint64 toPledge)\n    {\n        Pledge storage p = _findPledge(idPledge);\n        uint64[] memory newDelegationChain = new uint64[](\n            p.delegationChain.length - q\n        );\n\n        for (uint i = 0; i < p.delegationChain.length - q; i++) {\n            newDelegationChain[i] = p.delegationChain[i];\n        }\n        toPledge = _findOrCreatePledge(\n            p.owner,\n            newDelegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `proposeAssignProject` proposes the assignment of a pledge\n    ///  to a specific project.\n    /// @dev This function should potentially be named more specifically.\n    /// @param idPledge the id of the pledge that will be assigned.\n    /// @param amount Quantity of value this pledge leader would be assigned.\n    /// @param idReceiver The project this pledge will potentially \n    ///  be assigned to.\n    function _proposeAssignProject(\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) internal \n    {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(_getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n        require(!isProjectCanceled(idReceiver));\n\n        uint64 toPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            idReceiver,\n            uint64(_getTime() + _maxCommitTime(p)),\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n        _doTransfer(idPledge, toPledge, amount);\n    }\n\n    /// @notice `doTransfer` is designed to allow for pledge amounts to be \n    ///  shifted around internally.\n    /// @param from This is the id of the pledge from which value will be transferred.\n    /// @param to This is the id of the pledge that value will be transferred to.\n    /// @param _amount The amount of value that will be transferred.\n    function _doTransfer(uint64 from, uint64 to, uint _amount) internal {\n        uint amount = _callPlugins(true, from, to, _amount);\n        if (from == to) {\n            return;\n        }\n        if (amount == 0) {\n            return;\n        }\n\n        Pledge storage pFrom = _findPledge(from);\n        Pledge storage pTo = _findPledge(to);\n\n        require(pFrom.amount >= amount);\n        pFrom.amount -= amount;\n        pTo.amount += amount;\n        require(pTo.amount >= amount);\n\n        Transfer(from, to, amount);\n        _callPlugins(false, from, to, amount);\n    }\n\n    /// @notice A getter to find the longest commitTime out of the owner and all\n    ///  the delegates for a specified pledge\n    /// @param p The Pledge being queried\n    /// @return The maximum commitTime out of the owner and all the delegates\n    function _maxCommitTime(Pledge p) internal view returns(uint64 commitTime) {\n        PledgeAdmin storage a = _findAdmin(p.owner);\n        commitTime = a.commitTime; // start with the owner's commitTime\n\n        for (uint i = 0; i < p.delegationChain.length; i++) {\n            a = _findAdmin(p.delegationChain[i]);\n\n            // If a delegate's commitTime is longer, make it the new commitTime\n            if (a.commitTime > commitTime) {\n                commitTime = a.commitTime;\n            }\n        }\n    }\n\n    /// @notice A getter to find the oldest pledge that hasn't been canceled\n    /// @param idPledge The starting place to lookup the pledges\n    /// @return The oldest idPledge that hasn't been canceled (DUH!)\n    function _getOldestPledgeNotCanceled(\n        uint64 idPledge\n    ) internal view returns(uint64)\n    {\n        if (idPledge == 0) {\n            return 0;\n        }\n\n        Pledge storage p = _findPledge(idPledge);\n        PledgeAdmin storage admin = _findAdmin(p.owner);\n        \n        if (admin.adminType == PledgeAdminType.Giver) {\n            return idPledge;\n        }\n\n        assert(admin.adminType == PledgeAdminType.Project);\n        if (!isProjectCanceled(p.owner)) {\n            return idPledge;\n        }\n\n        return _getOldestPledgeNotCanceled(p.oldPledge);\n    }\n\n    /// @notice `callPlugin` is used to trigger the general functions in the\n    ///  plugin for any actions needed before and after a transfer happens.\n    ///  Specifically what this does in relation to the plugin is something\n    ///  that largely depends on the functions of that plugin. This function\n    ///  is generally called in pairs, once before, and once after a transfer.\n    /// @param before This toggle determines whether the plugin call is occurring\n    ///  before or after a transfer.\n    /// @param adminId This should be the Id of the *trusted* individual\n    ///  who has control over this plugin.\n    /// @param fromPledge This is the Id from which value is being transfered.\n    /// @param toPledge This is the Id that value is being transfered to.\n    /// @param context The situation that is triggering the plugin. See plugin\n    ///  for a full description of contexts.\n    /// @param amount The amount of value that is being transfered.\n    function _callPlugin(\n        bool before,\n        uint64 adminId,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint64 context,\n        address token,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        uint newAmount;\n        allowedAmount = amount;\n        PledgeAdmin storage admin = _findAdmin(adminId);\n\n        // Checks admin has a plugin assigned and a non-zero amount is requested\n        if (address(admin.plugin) != 0 && allowedAmount > 0) {\n            // There are two separate functions called in the plugin.\n            // One is called before the transfer and one after\n            if (before) {\n                newAmount = admin.plugin.beforeTransfer(\n                    adminId,\n                    fromPledge,\n                    toPledge,\n                    context,\n                    token,\n                    amount\n                );\n                require(newAmount <= allowedAmount);\n                allowedAmount = newAmount;\n            } else {\n                admin.plugin.afterTransfer(\n                    adminId,\n                    fromPledge,\n                    toPledge,\n                    context,\n                    token,\n                    amount\n                );\n            }\n        }\n    }\n\n    /// @notice `callPluginsPledge` is used to apply plugin calls to\n    ///  the delegate chain and the intended project if there is one.\n    ///  It does so in either a transferring or receiving context based\n    ///  on the `p` and  `fromPledge` parameters.\n    /// @param before This toggle determines whether the plugin call is occuring\n    ///  before or after a transfer.\n    /// @param idPledge This is the id of the pledge on which this plugin\n    ///  is being called.\n    /// @param fromPledge This is the Id from which value is being transfered.\n    /// @param toPledge This is the Id that value is being transfered to.\n    /// @param amount The amount of value that is being transfered.\n    function _callPluginsPledge(\n        bool before,\n        uint64 idPledge,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        // Determine if callPlugin is being applied in a receiving\n        // or transferring context\n        uint64 offset = idPledge == fromPledge ? 0 : 256;\n        allowedAmount = amount;\n        Pledge storage p = _findPledge(idPledge);\n\n        // Always call the plugin on the owner\n        allowedAmount = _callPlugin(\n            before,\n            p.owner,\n            fromPledge,\n            toPledge,\n            offset,\n            p.token,\n            allowedAmount\n        );\n\n        // Apply call plugin to all delegates\n        for (uint64 i = 0; i < p.delegationChain.length; i++) {\n            allowedAmount = _callPlugin(\n                before,\n                p.delegationChain[i],\n                fromPledge,\n                toPledge,\n                offset + i + 1,\n                p.token,\n                allowedAmount\n            );\n        }\n\n        // If there is an intended project also call the plugin in\n        // either a transferring or receiving context based on offset\n        // on the intended project\n        if (p.intendedProject > 0) {\n            allowedAmount = _callPlugin(\n                before,\n                p.intendedProject,\n                fromPledge,\n                toPledge,\n                offset + 255,\n                p.token,\n                allowedAmount\n            );\n        }\n    }\n\n    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer\n    ///  context and once for the receiving context. The aggregated \n    ///  allowed amount is then returned.\n    /// @param before This toggle determines whether the plugin call is occurring\n    ///  before or after a transfer.\n    /// @param fromPledge This is the Id from which value is being transferred.\n    /// @param toPledge This is the Id that value is being transferred to.\n    /// @param amount The amount of value that is being transferred.\n    function _callPlugins(\n        bool before,\n        uint64 fromPledge,\n        uint64 toPledge,\n        uint amount\n    ) internal returns (uint allowedAmount) \n    {\n        allowedAmount = amount;\n\n        // Call the plugins in the transfer context\n        allowedAmount = _callPluginsPledge(\n            before,\n            fromPledge,\n            fromPledge,\n            toPledge,\n            allowedAmount\n        );\n\n        // Call the plugins in the receive context\n        allowedAmount = _callPluginsPledge(\n            before,\n            toPledge,\n            fromPledge,\n            toPledge,\n            allowedAmount\n        );\n    }\n\n/////////////\n// Test functions\n/////////////\n\n    /// @notice Basic helper function to return the current time\n    function _getTime() internal view returns (uint) {\n        return now;\n    }\n}\n"
    },
    "./contracts/LiquidPledging.sol": {
      "keccak256": "0xa549270fe2f164f902b91543b5f3e0c41f1cf97a65f6a307a387534b900777e6",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LiquidPledging.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n/*\n    Copyright 2017, Jordi Baylina, RJ Ewing\n    Contributors: Adri√† Massanet <adria@codecontext.io>, Griff Green,\n    Arthur Lunn, Satya van Heummen <satya.vh@gmail.com>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledgingBase.sol\";\n\n/// @dev `LiquidPledging` allows for liquid pledging through the use of\n///  internal id structures and delegate chaining. All basic operations for\n///  handling liquid pledging are supplied as well as plugin features\n///  to allow for expanded functionality.\ncontract LiquidPledging is LiquidPledgingBase {\n\n    /// @notice Make a donation in Ether, basically forwarding to addGiverAndDonate method,\n    ///  setting msg.sender as the \"giver\" of this donation\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project    \n    function addGiverAndDonate(uint64 idReceiver)\n        public\n        payable\n    {\n        addGiverAndDonate(idReceiver, msg.sender, ETH, msg.value);\n    }\n\n    /// @notice Make a donation in Ether on behalf of another Giver\n    ///  basically forwarding to addGiverAndDonate method\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    /// @param donorAddress The address of the \"giver\" of this donation    \n    function addGiverAndDonate(uint64 idReceiver, address donorAddress)\n        public\n        payable\n    {\n        addGiverAndDonate(idReceiver, donorAddress, ETH, msg.value);\n    }    \n\n    /// Create a \"giver\" pledge admin for the sender & donate \n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    /// @param token The address of the token being donated.\n    /// @param amount The amount of tokens being donated\n    function addGiverAndDonate(uint64 idReceiver, address token, uint amount)\n        public\n    {\n        addGiverAndDonate(idReceiver, msg.sender, token, amount);\n    }\n\n    /// Create a \"giver\" pledge admin for the given `donorAddress` & donate \n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    /// @param donorAddress The address of the \"giver\" of this donation\n    /// @param token The address of the token being donated.\n    /// @param amount The amount of tokens being donated\n    function addGiverAndDonate(uint64 idReceiver, address donorAddress, address token, uint amount)\n        public\n    {\n        require(donorAddress != 0);\n        // default to a 3 day (259200 seconds) commitTime\n        uint64 idGiver = addGiver(donorAddress, \"\", \"\", 259200, ILiquidPledgingPlugin(0));\n        donate(idGiver, idReceiver, token, amount);\n    }\n\n    /// @notice Make a donation in Ether, basically forwarding to donate method\n    ///  setting the msg.sender as the \"giver\" of the donation\n    /// @param idGiver The id of the Giver donating\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    function donate(uint64 idGiver, uint64 idReceiver)\n        public\n        payable\n    {\n        donate(idGiver, idReceiver, ETH, msg.value);\n    }\n\n    /// @notice This is how value enters the system and how pledges are created;\n    ///  the ether is sent to the vault, a pledge for the Giver is created (or\n    ///  found), the amount of ETH donated in wei is added to the `amount` in\n    ///  the Giver's Pledge, and an LP transfer is done to the idReceiver for\n    ///  the full amount\n    /// @param idGiver The id of the Giver donating\n    /// @param idReceiver The Admin receiving the donation; can be any Admin:\n    ///  the Giver themselves, another Giver, a Delegate or a Project\n    /// @param token The address of the token being donated.\n    /// @param amount The amount of tokens being donated\n    function donate(uint64 idGiver, uint64 idReceiver, address token, uint amount)\n        public\n    {\n        require(idGiver > 0); // prevent burning donations. idReceiver is checked in _transfer\n        require(amount > 0);\n\n        PledgeAdmin storage sender = _findAdmin(idGiver);\n        require(sender.adminType == PledgeAdminType.Giver);\n\n        // transfer ether or token to the `vault`\n        if (token == ETH) {\n            vault.transfer(amount);\n        } else {\n            require(ERC20(token).transferFrom(msg.sender, address(vault), amount));\n        }\n\n        uint64 idPledge = _findOrCreatePledge(\n            idGiver,\n            new uint64[](0), // Creates empty array for delegationChain\n            0,\n            0,\n            0,\n            token,\n            PledgeState.Pledged\n        );\n\n        Pledge storage pTo = _findPledge(idPledge);\n        pTo.amount += amount;\n\n        Transfer(0, idPledge, amount);\n\n        _transfer(idGiver, idPledge, amount, idReceiver);\n    }\n\n    /// @notice Transfers amounts between pledges for internal accounting\n    /// @param idSender Id of the Admin that is transferring the amount from\n    ///  Pledge to Pledge; this admin must have permissions to move the value\n    /// @param idPledge Id of the pledge that's moving the value\n    /// @param amount Quantity of ETH (in wei) that this pledge is transferring \n    ///  the authority to withdraw from the vault\n    /// @param idReceiver Destination of the `amount`, can be a Giver/Project sending\n    ///  to a Giver, a Delegate or a Project; a Delegate sending to another\n    ///  Delegate, or a Delegate pre-commiting it to a Project \n    function transfer( \n        uint64 idSender,\n        uint64 idPledge,\n        uint amount,\n        uint64 idReceiver\n    ) public\n    {\n        _checkAdminOwner(idSender);\n        _transfer(idSender, idPledge, amount, idReceiver);\n    }\n\n    /// @notice Authorizes a payment be made from the `vault` can be used by the\n    ///  Giver to veto a pre-committed donation from a Delegate to an\n    ///  intendedProject\n    /// @param idPledge Id of the pledge that is to be redeemed into ether\n    /// @param amount Quantity of ether (in wei) to be authorized\n    function withdraw(uint64 idPledge, uint amount) public {\n        idPledge = normalizePledge(idPledge); // Updates pledge info \n\n        Pledge storage p = _findPledge(idPledge);\n        require(p.pledgeState == PledgeState.Pledged);\n        _checkAdminOwner(p.owner);\n\n        uint64 idNewPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Paying\n        );\n\n        _doTransfer(idPledge, idNewPledge, amount);\n\n        PledgeAdmin storage owner = _findAdmin(p.owner);\n        vault.authorizePayment(bytes32(idNewPledge), owner.addr, p.token, amount);\n    }\n\n    /// @notice `onlyVault` Confirms a withdraw request changing the PledgeState\n    ///  from Paying to Paid\n    /// @param idPledge Id of the pledge that is to be withdrawn\n    /// @param amount Quantity of ether (in wei) to be withdrawn\n    function confirmPayment(uint64 idPledge, uint amount) public onlyVault {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.pledgeState == PledgeState.Paying);\n\n        uint64 idNewPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Paid\n        );\n\n        _doTransfer(idPledge, idNewPledge, amount);\n    }\n\n    /// @notice `onlyVault` Cancels a withdraw request, changing the PledgeState\n    ///  from Paying back to Pledged\n    /// @param idPledge Id of the pledge that's withdraw is to be canceled\n    /// @param amount Quantity of ether (in wei) to be canceled\n    function cancelPayment(uint64 idPledge, uint amount) public onlyVault {\n        Pledge storage p = _findPledge(idPledge);\n\n        require(p.pledgeState == PledgeState.Paying);\n\n        // When a payment is canceled, never is assigned to a project.\n        uint64 idOldPledge = _findOrCreatePledge(\n            p.owner,\n            p.delegationChain,\n            0,\n            0,\n            p.oldPledge,\n            p.token,\n            PledgeState.Pledged\n        );\n\n        idOldPledge = normalizePledge(idOldPledge);\n\n        _doTransfer(idPledge, idOldPledge, amount);\n    }\n\n    /// @notice Changes the `project.canceled` flag to `true`; cannot be undone\n    /// @param idProject Id of the project that is to be canceled\n    function cancelProject(uint64 idProject) public {\n        PledgeAdmin storage project = _findAdmin(idProject);\n        _checkAdminOwner(idProject);\n        project.canceled = true;\n\n        CancelProject(idProject);\n    }\n\n    /// @notice Transfers `amount` in `idPledge` back to the `oldPledge` that\n    ///  that sent it there in the first place, a Ctrl-z \n    /// @param idPledge Id of the pledge that is to be canceled\n    /// @param amount Quantity of ether (in wei) to be transfered to the \n    ///  `oldPledge`\n    function cancelPledge(uint64 idPledge, uint amount) public {\n        idPledge = normalizePledge(idPledge);\n\n        Pledge storage p = _findPledge(idPledge);\n        require(p.oldPledge != 0);\n        require(p.pledgeState == PledgeState.Pledged);\n        _checkAdminOwner(p.owner);\n\n        uint64 oldPledge = _getOldestPledgeNotCanceled(p.oldPledge);\n        _doTransfer(idPledge, oldPledge, amount);\n    }\n\n\n////////\n// Multi pledge methods\n////////\n\n    // @dev This set of functions makes moving a lot of pledges around much more\n    // efficient (saves gas) than calling these functions in series\n    \n    \n    /// @dev Bitmask used for dividing pledge amounts in Multi pledge methods\n    uint constant D64 = 0x10000000000000000;\n\n    /// @notice Transfers multiple amounts within multiple Pledges in an\n    ///  efficient single call \n    /// @param idSender Id of the Admin that is transferring the amounts from\n    ///  all the Pledges; this admin must have permissions to move the value\n    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with \n    ///  which the amounts are associated; these are extrapolated using the D64\n    ///  bitmask\n    /// @param idReceiver Destination of the `pledesAmounts`, can be a Giver or \n    ///  Project sending to a Giver, a Delegate or a Project; a Delegate sending\n    ///  to another Delegate, or a Delegate pre-commiting it to a Project \n    function mTransfer(\n        uint64 idSender,\n        uint[] pledgesAmounts,\n        uint64 idReceiver\n    ) public \n    {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            transfer(idSender, idPledge, amount, idReceiver);\n        }\n    }\n\n    /// @notice Authorizes multiple amounts within multiple Pledges to be\n    ///  withdrawn from the `vault` in an efficient single call \n    /// @param pledgesAmounts An array of Pledge amounts and the idPledges with \n    ///  which the amounts are associated; these are extrapolated using the D64\n    ///  bitmask\n    function mWithdraw(uint[] pledgesAmounts) public {\n        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n            uint64 idPledge = uint64(pledgesAmounts[i] & (D64-1));\n            uint amount = pledgesAmounts[i] / D64;\n\n            withdraw(idPledge, amount);\n        }\n    }\n\n    /// @notice `mNormalizePledge` allows for multiple pledges to be\n    ///  normalized efficiently\n    /// @param pledges An array of pledge IDs\n    function mNormalizePledge(uint64[] pledges) public {\n        for (uint i = 0; i < pledges.length; i++ ) {\n            normalizePledge(pledges[i]);\n        }\n    }\n}\n"
    },
    "./contracts/LiquidPledgingMock.sol": {
      "keccak256": "0x6f2e8b228281fc3cfbef9447e45b084c1507fdaff3361735a81aa672c4a1309d",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/LiquidPledgingMock.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n/*\n    Copyright 2017, Jordi Baylina\n    Contributor: Adri√† Massanet <adria@codecontext.io>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport \"./LiquidPledging.sol\";\n\n/// @dev `LiquidPledgingMock` allows for mocking up\n///  a `LiquidPledging` contract with the added ability\n///  to manipulate the block time for testing purposes.\ncontract LiquidPledgingMock is LiquidPledging {\n\n    uint public mock_time;\n\n    /// @dev `LiquidPledgingMock` creates a standard `LiquidPledging`\n    ///  instance and sets the mocked time to the current blocktime.\n    function initialize(address _vault) onlyInit public {\n        super.initialize(_vault);\n        mock_time = now;\n    }\n\n    /// @dev `getTime` is a basic getter function for\n    ///  the mock_time parameter\n    function _getTime() internal view returns (uint) {\n        return mock_time;\n    }\n\n    /// @dev `setMockedTime` is a basic setter function for\n    ///  the mock_time parameter\n    /// @param _t This is the value to which the mocked time\n    ///  will be set.\n    function setMockedTime(uint _t) public {\n        mock_time = _t;\n    }\n}\n"
    },
    "./contracts/test/TestSimpleDelegatePlugin.sol": {
      "keccak256": "0xbdfa9879133351c80acbb3d5bd4902be490118838bd88dfc7fd46007731ad10e",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/test/TestSimpleDelegatePlugin.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../LiquidPledging.sol\";\n\n// simple liquidPledging plugin contract for testing whitelist\ncontract TestSimpleDelegatePlugin {\n\n    uint64 public idDelegate;\n    LiquidPledging liquidPledging;\n    bool initPending;\n\n    event BeforeTransfer(uint64 pledgeAdmin, uint64 pledgeFrom, uint64 pledgeTo, uint64 context, uint amount);\n    event AfterTransfer(uint64 pledgeAdmin, uint64 pledgeFrom, uint64 pledgeTo, uint64 context, uint amount);\n\n    function TestSimpleDelegatePlugin(LiquidPledging _liquidPledging) public {\n        require(msg.sender != tx.origin); // Avoids being created directly by mistake.\n        liquidPledging = _liquidPledging;\n        initPending = true;\n    }\n\n    function init(\n        string name,\n        string url,\n        uint64 commitTime\n    ) public {\n        require(initPending);\n        idDelegate = liquidPledging.addDelegate(name, url, commitTime, ILiquidPledgingPlugin(this));\n        initPending = false;\n    }\n\n    function beforeTransfer(\n        uint64 pledgeAdmin,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        uint amount\n    ) external returns (uint maxAllowed) {\n        require(!initPending);\n        maxAllowed;\n        BeforeTransfer(pledgeAdmin, pledgeFrom, pledgeTo, context, amount);\n    }\n\n    function afterTransfer(\n        uint64 pledgeAdmin,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        uint amount\n    ) external {\n        require(!initPending);\n        AfterTransfer(pledgeAdmin, pledgeFrom, pledgeTo, context, amount);\n    }\n\n}\n\ncontract TestSimpleDelegatePluginFactory {\n\n    function TestSimpleDelegatePluginFactory(\n        LiquidPledging liquidPledging,\n        string name,\n        string url,\n        uint64 commitTime\n    ) public {\n        TestSimpleDelegatePlugin d = new TestSimpleDelegatePlugin(liquidPledging);\n        d.init(name, url, commitTime);\n    }\n\n}\n"
    },
    "./contracts/test/TestSimpleProjectPlugin.sol": {
      "keccak256": "0xa942aca3c4a33b75973b578708a0707c15807680f7ff4333149ec510fc7f33b0",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/test/TestSimpleProjectPlugin.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../LiquidPledging.sol\";\n\n// simple liquidPledging plugin contract for testing whitelist\ncontract TestSimpleProjectPlugin {\n\n    uint64 public idProject;\n    bool initPending;\n\n    event BeforeTransfer(uint64 pledgeAdmin, uint64 pledgeFrom, uint64 pledgeTo, uint64 context, uint amount);\n    event AfterTransfer(uint64 pledgeAdmin, uint64 pledgeFrom, uint64 pledgeTo, uint64 context, uint amount);\n\n    function TestSimpleProjectPlugin() public {\n        require(msg.sender != tx.origin); // Avoids being created directly by mistake.\n        initPending = true;\n    }\n\n    function init(\n        LiquidPledging liquidPledging,\n        string name,\n        string url,\n        uint64 parentProject\n    ) public {\n        require(initPending);\n        idProject = liquidPledging.addProject(name, url, address(this), parentProject, 0, ILiquidPledgingPlugin(this));\n        initPending = false;\n    }\n\n    function beforeTransfer(\n        uint64 pledgeAdmin,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        uint amount\n    ) external returns (uint maxAllowed) {\n        require(!initPending);\n        maxAllowed;\n        BeforeTransfer(pledgeAdmin, pledgeFrom, pledgeTo, context, amount);\n    }\n\n    function afterTransfer(\n        uint64 pledgeAdmin,\n        uint64 pledgeFrom,\n        uint64 pledgeTo,\n        uint64 context,\n        uint amount\n    ) external {\n        require(!initPending);\n        AfterTransfer(pledgeAdmin, pledgeFrom, pledgeTo, context, amount);\n    }\n\n}\n"
    },
    "./contracts/test/TestSimpleProjectPluginFactory.sol": {
      "keccak256": "0x250a38dec04be52b89d2d7112d1dc41799e2aaef284ac22e5531f364c7427047",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/contracts/test/TestSimpleProjectPluginFactory.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\nimport \"./TestSimpleProjectPlugin.sol\";\nimport \"../LiquidPledging.sol\";\n\n// simple factory for deploying TestSimpleProjectPlugin.sol contract\ncontract TestSimpleProjectPluginFactory {\n\n    function deploy(\n        LiquidPledging liquidPledging,\n        string name,\n        string url,\n        uint64 parentProject\n    ) public {\n        TestSimpleProjectPlugin p = new TestSimpleProjectPlugin();\n        p.init(liquidPledging, name, url, parentProject);\n    }\n\n}\n"
    },
    "./node_modules/@aragon/os/contracts/kernel/Kernel.sol": {
      "keccak256": "0x924bb490f4f12d54806b512aeb107f22443c7138f229b087da06938364ae702b",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/kernel/Kernel.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./IKernel.sol\";\nimport \"./KernelStorage.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../lib/misc/ERCProxy.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/IsContract.sol\";\nimport \"../common/VaultRecoverable.sol\";\nimport \"../factory/AppProxyFactory.sol\";\n\n\ncontract Kernel is IKernel, KernelStorage, Initializable, IsContract, AppProxyFactory, ACLSyntaxSugar, VaultRecoverable {\n    // Hardocde constant to save gas\n    //bytes32 constant public APP_MANAGER_ROLE = keccak256(\"APP_MANAGER_ROLE\");\n    //bytes32 constant public DEFAULT_VAULT_ID = keccak256(APP_ADDR_NAMESPACE, apmNamehash(\"vault\"));\n    bytes32 constant public APP_MANAGER_ROLE = 0xb6d92708f3d4817afc106147d969e229ced5c46e65e0a5002a0d391287762bd0;\n    bytes32 constant public DEFAULT_VAULT_ID = 0x4214e5fd6d0170d69ea641b5614f5093ebecc9928af51e95685c87617489800e;\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes a kernel instance along with its ACL and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _baseAcl Address of base ACL app\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _baseAcl, address _permissionsCreator) onlyInit public {\n        initialized();\n\n        IACL acl = IACL(newAppProxy(this, ACL_APP_ID));\n\n        _setApp(APP_BASES_NAMESPACE, ACL_APP_ID, _baseAcl);\n        _setApp(APP_ADDR_NAMESPACE, ACL_APP_ID, acl);\n\n        acl.initialize(_permissionsCreator);\n\n        recoveryVaultId = DEFAULT_VAULT_ID;\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (ERCProxy appProxy) {\n        return newAppInstance(_name, _appBase, false);\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel and set its base\n    *      implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @param _setDefault Whether the app proxy app is the default one.\n    *        Useful when the Kernel needs to know of an instance of a particular app,\n    *        like Vault for escape hatch mechanism.\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _name, address _appBase, bool _setDefault) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (ERCProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxy(this, _name);\n        // By calling setApp directly and not the internal functions, we make sure the params are checked\n        // and it will only succeed if sender has permissions to set something to the namespace.\n        if (_setDefault) {\n            setApp(APP_ADDR_NAMESPACE, _name, appProxy);\n        }\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _name, address _appBase) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (ERCProxy appProxy) {\n        return newPinnedAppInstance(_name, _appBase, false);\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel and set\n    *      its base implementation if it was not already set\n    * @param _name Name of the app\n    * @param _appBase Address of the app's base implementation\n    * @param _setDefault Whether the app proxy app is the default one.\n    *        Useful when the Kernel needs to know of an instance of a particular app,\n    *        like Vault for escape hatch mechanism.\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _name, address _appBase, bool _setDefault) auth(APP_MANAGER_ROLE, arr(APP_BASES_NAMESPACE, _name)) public returns (ERCProxy appProxy) {\n        _setAppIfNew(APP_BASES_NAMESPACE, _name, _appBase);\n        appProxy = newAppProxyPinned(this, _name);\n        // By calling setApp directly and not the internal functions, we make sure the params are checked\n        // and it will only succeed if sender has permissions to set something to the namespace.\n        if (_setDefault) {\n            setApp(APP_ADDR_NAMESPACE, _name, appProxy);\n        }\n    }\n\n    /**\n    * @dev Set the resolving address of an app instance or base implementation\n    * @param _namespace App namespace to use\n    * @param _name Name of the app\n    * @param _app Address of the app\n    * @return ID of app\n    */\n    function setApp(bytes32 _namespace, bytes32 _name, address _app) auth(APP_MANAGER_ROLE, arr(_namespace, _name)) kernelIntegrity public returns (bytes32 id) {\n        return _setApp(_namespace, _name, _app);\n    }\n\n    /**\n    * @dev Get the address of an app instance or base implementation\n    * @param _id App identifier\n    * @return Address of the app\n    */\n    function getApp(bytes32 _id) public view returns (address) {\n        return apps[_id];\n    }\n\n    /**\n    * @dev Get the address of the recovery Vault instance (to recover funds)\n    * @return Address of the Vault\n    */\n    function getRecoveryVault() public view returns (address) {\n        return apps[recoveryVaultId];\n    }\n\n    /**\n    * @dev Set the default vault id for the escape hatch mechanism\n    * @param _name Name of the app\n    */\n    function setRecoveryVaultId(bytes32 _name) auth(APP_MANAGER_ROLE, arr(APP_ADDR_NAMESPACE, _name)) public {\n        recoveryVaultId = keccak256(APP_ADDR_NAMESPACE, _name);\n    }\n\n    /**\n    * @dev Get the installed ACL app\n    * @return ACL app\n    */\n    function acl() public view returns (IACL) {\n        return IACL(getApp(ACL_APP));\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission status\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _what Identifier for a group of actions in app\n    * @param _how Extra data for ACL auth\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\n        return acl().hasPermission(_who, _where, _what, _how);\n    }\n\n    function _setApp(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        require(isContract(_app));\n        id = keccak256(_namespace, _name);\n        apps[id] = _app;\n        SetApp(_namespace, _name, id, _app);\n    }\n\n    function _setAppIfNew(bytes32 _namespace, bytes32 _name, address _app) internal returns (bytes32 id) {\n        require(isContract(_app));\n\n        id = keccak256(_namespace, _name);\n\n        address app = getApp(id);\n        if (app != address(0)) {\n            require(app == _app);\n        } else {\n            apps[id] = _app;\n            SetApp(_namespace, _name, id, _app);\n        }\n    }\n\n    modifier auth(bytes32 _role, uint256[] memory params) {\n        bytes memory how;\n        uint256 byteLength = params.length * 32;\n        assembly {\n            how := params // forced casting\n            mstore(how, byteLength)\n        }\n        // Params is invalid from this point fwd\n        require(hasPermission(msg.sender, address(this), _role, how));\n        _;\n    }\n\n    modifier kernelIntegrity {\n        _; // After execution check integrity\n        address kernel = getApp(KERNEL_APP);\n        uint256 size;\n        assembly { size := extcodesize(kernel) }\n        require(size > 0);\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/acl/IACL.sol": {
      "keccak256": "0xa120fc32d8d2c5096d605b0fe012d5b1e4a62118952a25a18bac5210f4fceede",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/acl/IACL.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IACL {\n    function initialize(address permissionsCreator) public;\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/IVaultRecoverable.sol": {
      "keccak256": "0xf6ed3f4043aee4526c9563c83f74d701141dd81a988f1be463ba6a18e09ba2c3",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/common/IVaultRecoverable.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IVaultRecoverable {\n    function transferToVault(address token) external;\n\n    function allowRecoverability(address token) public view returns (bool);\n    function getRecoveryVault() public view returns (address);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/kernel/IKernel.sol": {
      "keccak256": "0x1f0c5def4ecec01abcbb07eea3312e0a4683d81a81c2475d66f06c5c3b8585cd",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/kernel/IKernel.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../acl/IACL.sol\";\nimport \"../common/IVaultRecoverable.sol\";\n\n\n// This should be an interface, but interfaces can't inherit yet :(\ncontract IKernel is IVaultRecoverable {\n    event SetApp(bytes32 indexed namespace, bytes32 indexed name, bytes32 indexed id, address app);\n\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 name, address app) public returns (bytes32 id);\n    function getApp(bytes32 id) public view returns (address);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/kernel/KernelStorage.sol": {
      "keccak256": "0x0081232c1c7a013e1cb31868d7950f980286c09b05c767a4102ca4090cd6ef9a",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/kernel/KernelStorage.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\n\ncontract KernelConstants {\n    /*\n    bytes32 constant public CORE_NAMESPACE = keccak256(\"core\");\n    bytes32 constant public APP_BASES_NAMESPACE = keccak256(\"base\");\n    bytes32 constant public APP_ADDR_NAMESPACE = keccak256(\"app\");\n\n    bytes32 constant public KERNEL_APP_ID = apmNamehash(\"kernel\");\n    bytes32 constant public KERNEL_APP = keccak256(CORE_NAMESPACE, KERNEL_APP_ID);\n\n    bytes32 constant public ACL_APP_ID = apmNamehash(\"acl\");\n    bytes32 constant public ACL_APP = keccak256(APP_ADDR_NAMESPACE, ACL_APP_ID);\n    */\n    bytes32 constant public CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\n    bytes32 constant public APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\n    bytes32 constant public APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\n    bytes32 constant public ETH_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 constant public APM_NODE = 0x9065c3e7f7b7ef1ef4e53d2d0b8e0cef02874ab020c1ece79d5f0d3d0111c0ba;\n    bytes32 constant public KERNEL_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\n    bytes32 constant public KERNEL_APP = 0x2b7d19d0575c228f8d9326801e14149d284dc5bb7b1541c5ad712ae4b2fcaadb;\n    bytes32 constant public ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\n    bytes32 constant public ACL_APP = 0x4b8e03a458a6ccec5d9077c2490964c1333dd3c72e2db408d7d9a7a36ef5c41a;\n\n}\n\n\ncontract KernelStorage is KernelConstants {\n    mapping (bytes32 => address) public apps;\n    bytes32 public recoveryVaultId;\n}\n"
    },
    "./node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol": {
      "keccak256": "0xb60f567383dd66e25eaf0925320fdff8d5c57d4f1f74a7a53a9573b61876340e",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ncontract ACLSyntaxSugar {\n    function arr() internal pure returns (uint256[] r) {}\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}\n\n\ncontract ACLHelpers {\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/lib/misc/ERCProxy.sol": {
      "keccak256": "0xba656dc63cdfe99f80d29e0a4e15538e7915aada88ba52967a1de063225611ca",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/lib/misc/ERCProxy.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ncontract ERCProxy {\n    uint256 constant public FORWARDING = 1;\n    uint256 constant public UPGRADEABLE = 2;\n\n    function proxyType() public pure returns (uint256 proxyTypeId);\n    function implementation() public view returns (address codeAddr);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/AppStorage.sol": {
      "keccak256": "0x8b9205a3fdf9d94fb1461d2c2d32335803122aa75d3fa8cf0b982796fd040c25",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/apps/AppStorage.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppStorage {\n    IKernel public kernel;\n    bytes32 public appId;\n    address internal pinnedCode; // used by Proxy Pinned\n    uint256 internal initializationBlock; // used by Initializable\n    uint256[95] private storageOffset; // forces App storage to start at after 100 slots\n    uint256 private offset;\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/Initializable.sol": {
      "keccak256": "0x1265fd5de8acf30e4b444f52cfdf91dcebb222fe05bdfc081f2fc0ea953ab5e4",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/common/Initializable.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"../apps/AppStorage.sol\";\n\n\ncontract Initializable is AppStorage {\n    modifier onlyInit {\n        require(initializationBlock == 0);\n        _;\n    }\n\n    modifier isInitialized {\n        require(initializationBlock > 0);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        initializationBlock = getBlockNumber();\n    }\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/IsContract.sol": {
      "keccak256": "0xee6df8a68ea442a2c0414ee70d95eb3e197425ce372a28bfda01888b0d9446f1",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/common/IsContract.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ncontract IsContract {\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/EtherTokenConstant.sol": {
      "keccak256": "0x160b651ec349ce381646d8ba24b873a61ab4bf0d60315b9644a175283a574b94",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/common/EtherTokenConstant.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\n// contracts where both tokens and ETH are accepted\ncontract EtherTokenConstant {\n    address constant public ETH = address(0);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/lib/zeppelin/token/ERC20Basic.sol": {
      "keccak256": "0x3ad7429b6f0a6330e8e89646aef39de99fa1fd8221e6a9dd55e3a9104908d585",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/lib/zeppelin/token/ERC20Basic.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/lib/zeppelin/token/ERC20.sol": {
      "keccak256": "0x48674c3983e4e9ba8f771d28e349833164934960a952966c17ae05f05fa84379",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/lib/zeppelin/token/ERC20.sol"
      ],
      "content": "pragma solidity ^0.4.11;\n\n\nimport './ERC20Basic.sol';\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/VaultRecoverable.sol": {
      "keccak256": "0x1b71cbea32aee6e65912e3447eb8001bdad127d421e0c4464bb8294f945d9cf1",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/common/VaultRecoverable.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./EtherTokenConstant.sol\";\nimport \"./IsContract.sol\";\nimport \"./IVaultRecoverable.sol\";\nimport \"../lib/zeppelin/token/ERC20.sol\";\n\n\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\n    /**\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\n     *         but in case it does, this function allows one to recover them.\n     * @param _token Token balance to be sent to recovery vault.\n     */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token));\n        address vault = getRecoveryVault();\n        require(isContract(vault));\n\n        if (_token == ETH) {\n            vault.transfer(this.balance);\n        } else {\n            uint256 amount = ERC20(_token).balanceOf(this);\n            ERC20(_token).transfer(vault, amount);\n        }\n    }\n\n    /**\n    * @dev By default deriving from AragonApp makes it recoverable\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/DelegateProxy.sol": {
      "keccak256": "0xc08eb0dec7d649648c9e15f7d3906fc979f62b6cb7cccc6553d6bf4d2ed2f63a",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/common/DelegateProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../common/IsContract.sol\";\nimport \"../lib/misc/ERCProxy.sol\";\n\n\ncontract DelegateProxy is ERCProxy, IsContract {\n    uint256 constant public FWD_GAS_LIMIT = 10000;\n\n    /**\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n    * @param _dst Destination address to perform the delegatecall\n    * @param _calldata Calldata for the delegatecall\n    */\n    function delegatedFwd(address _dst, bytes _calldata) internal {\n        delegatedFwd(_dst, _calldata, 0);\n    }\n\n    /**\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n    * @param _dst Destination address to perform the delegatecall\n    * @param _calldata Calldata for the delegatecall\n    * @param _minReturnSize Minimum size the call needs to return, if less than that it will revert\n    */\n    function delegatedFwd(address _dst, bytes _calldata, uint256 _minReturnSize) internal {\n        require(isContract(_dst));\n        uint256 size;\n        uint256 result;\n        uint256 fwd_gas_limit = FWD_GAS_LIMIT;\n\n        assembly {\n            result := delegatecall(sub(gas, fwd_gas_limit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            size := returndatasize\n        }\n\n        require(size >= _minReturnSize);\n\n        assembly {\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/common/DepositableDelegateProxy.sol": {
      "keccak256": "0x91bf6e5fa17af2d12f5923d5da45a42de8a1b75a54d466705a3140fc3606db18",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/common/DepositableDelegateProxy.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./DelegateProxy.sol\";\n\n\ncontract DepositableDelegateProxy is DelegateProxy {\n    event ProxyDeposit(address sender, uint256 value);\n\n    function () payable public {\n        // send / transfer\n        if (msg.gas < FWD_GAS_LIMIT) {\n            require(msg.value > 0 && msg.data.length == 0);\n            ProxyDeposit(msg.sender, msg.value);\n        } else { // all calls except for send or transfer\n            address target = implementation();\n            delegatedFwd(target, msg.data);\n        }\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/AppProxyBase.sol": {
      "keccak256": "0xc084b7b69ae72fb0dcbbf426517aa65fd5842309dea77831a993d0f5fff01c10",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/apps/AppProxyBase.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppStorage.sol\";\nimport \"../common/DepositableDelegateProxy.sol\";\nimport \"../kernel/KernelStorage.sol\";\n\n\ncontract AppProxyBase is AppStorage, DepositableDelegateProxy, KernelConstants {\n    /**\n    * @dev Initialize AppProxy\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyBase(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n        kernel = _kernel;\n        appId = _appId;\n\n        // Implicit check that kernel is actually a Kernel\n        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\n        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n        // it.\n        address appCode = getAppBase(appId);\n\n        // If initialize payload is provided, it will be executed\n        if (_initializePayload.length > 0) {\n            require(isContract(appCode));\n            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n            // returns ending execution context and halts contract deployment\n            require(appCode.delegatecall(_initializePayload));\n        }\n    }\n\n    function getAppBase(bytes32 _appId) internal view returns (address) {\n        return kernel.getApp(keccak256(APP_BASES_NAMESPACE, _appId));\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/AppProxyUpgradeable.sol": {
      "keccak256": "0x399a61bef2ea0035edf7adc57f731620bc2f6d044e715ac6f894e51e16d3f1b9",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/apps/AppProxyUpgradeable.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyUpgradeable is AppProxyBase {\n    /**\n    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyUpgradeable(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n\n    }\n\n    /**\n     * @dev ERC897, the address the proxy would delegate calls to\n     */\n    function implementation() public view returns (address) {\n        return getAppBase(appId);\n    }\n\n    /**\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n     */\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return UPGRADEABLE;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/AppProxyPinned.sol": {
      "keccak256": "0x5a18cba7c2b3f0118516dae74e05ca95ffa7d845353869609db41173660ebdc9",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/apps/AppProxyPinned.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyPinned is AppProxyBase {\n    /**\n    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    function AppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n             AppProxyBase(_kernel, _appId, _initializePayload) public\n    {\n        pinnedCode = getAppBase(appId);\n        require(pinnedCode != address(0));\n    }\n\n    /**\n     * @dev ERC897, the address the proxy would delegate calls to\n     */\n    function implementation() public view returns (address) {\n        return pinnedCode;\n    }\n\n    /**\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n     */\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return FORWARDING;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/factory/AppProxyFactory.sol": {
      "keccak256": "0x472a3f313ca8ecdb36f6c1a0fd7eeb829c2c4d1d7c040edf6808dfa42e104eaf",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/factory/AppProxyFactory.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AppProxyUpgradeable.sol\";\nimport \"../apps/AppProxyPinned.sol\";\n\n\ncontract AppProxyFactory {\n    event NewAppProxy(address proxy, bool isUpgradeable, bytes32 appId);\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n        return newAppProxy(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy), true, _appId);\n        return proxy;\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n    }\n\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n        NewAppProxy(address(proxy), false, _appId);\n        return proxy;\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/acl/ACL.sol": {
      "keccak256": "0x6af19edaa165221caae72f959d47a94fc8379dfdf622c0314f374b3723c1b9d9",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/acl/ACL.sol"
      ],
      "content": "pragma solidity 0.4.18;\n\nimport \"../apps/AragonApp.sol\";\nimport \"./ACLSyntaxSugar.sol\";\nimport \"./IACL.sol\";\n\n\ninterface ACLOracle {\n    function canPerform(address who, address where, bytes32 what, uint256[] how) public view returns (bool);\n}\n\n\ncontract ACL is IACL, AragonApp, ACLHelpers {\n    // Hardcoded constant to save gas\n    //bytes32 constant public CREATE_PERMISSIONS_ROLE = keccak256(\"CREATE_PERMISSIONS_ROLE\");\n    bytes32 constant public CREATE_PERMISSIONS_ROLE = 0x0b719b33c83b8e5d300c521cb8b54ae9bd933996a14bef8c2f4e0285d2d2400a;\n\n    // whether a certain entity has a permission\n    mapping (bytes32 => bytes32) permissions; // 0 for no permission, or parameters id\n    mapping (bytes32 => Param[]) public permissionParams;\n\n    // who is the manager of a permission\n    mapping (bytes32 => address) permissionManager;\n\n    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, RET, NOT, AND, OR, XOR, IF_ELSE } // op types\n\n    struct Param {\n        uint8 id;\n        uint8 op;\n        uint240 value; // even though value is an uint240 it can store addresses\n        // in the case of 32 byte hashes losing 2 bytes precision isn't a huge deal\n        // op and id take less than 1 byte each so it can be kept in 1 sstore\n    }\n\n    uint8 constant BLOCK_NUMBER_PARAM_ID = 200;\n    uint8 constant TIMESTAMP_PARAM_ID    = 201;\n    uint8 constant SENDER_PARAM_ID       = 202;\n    uint8 constant ORACLE_PARAM_ID       = 203;\n    uint8 constant LOGIC_OP_PARAM_ID     = 204;\n    uint8 constant PARAM_VALUE_PARAM_ID  = 205;\n    // TODO: Add execution times param type?\n\n    // Hardcoded constant to save gas\n    //bytes32 constant public EMPTY_PARAM_HASH = keccak256(uint256(0));\n    bytes32 constant public EMPTY_PARAM_HASH = 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563;\n    address constant ANY_ENTITY = address(-1);\n\n    modifier onlyPermissionManager(address _app, bytes32 _role) {\n        require(msg.sender == getPermissionManager(_app, _role));\n        _;\n    }\n\n    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\n    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initializes an ACL instance and sets `_permissionsCreator` as the entity that can create other permissions\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _permissionsCreator) onlyInit public {\n        initialized();\n        require(msg.sender == address(kernel));\n\n        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\n    }\n\n    /**\n    * @dev Creates a permission that wasn't previously set and managed. Access is limited by the ACL.\n    *      If a created permission is removed it is possible to reset it with createPermission.\n    * @notice Create a new permission granting `_entity` the ability to perform actions of role `_role` on `_app` (setting `_manager` as the permission manager)\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\n    */\n    function createPermission(address _entity, address _app, bytes32 _role, address _manager) external {\n        require(hasPermission(msg.sender, address(this), CREATE_PERMISSIONS_ROLE));\n\n        _createPermission(_entity, _app, _role, _manager);\n    }\n\n    /**\n    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    */\n    function grantPermission(address _entity, address _app, bytes32 _role)\n        external\n    {\n        grantPermissionP(_entity, _app, _role, new uint256[](0));\n    }\n\n    /**\n    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grants `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _params Permission parameters\n    */\n    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\n        onlyPermissionManager(_app, _role)\n        public\n    {\n        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\n        _setPermission(_entity, _app, _role, paramsHash);\n    }\n\n    /**\n    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\n    * @notice Revokes `_entity` the ability to perform actions of role `_role` on `_app`\n    * @param _entity Address of the whitelisted entity to revoke access from\n    * @param _app Address of the app in which the role will be revoked\n    * @param _role Identifier for the group of actions in app being revoked\n    */\n    function revokePermission(address _entity, address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        _setPermission(_entity, _app, _role, bytes32(0));\n    }\n\n    /**\n    * @notice Sets `_newManager` as the manager of the permission `_role` in `_app`\n    * @param _newManager Address for the new manager\n    * @param _app Address of the app in which the permission management is being transferred\n    * @param _role Identifier for the group of actions being transferred\n    */\n    function setPermissionManager(address _newManager, address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        _setPermissionManager(_newManager, _app, _role);\n    }\n\n    /**\n    * @notice Removes the manager of the permission `_role` in `_app`\n    * @param _app Address of the app in which the permission is being unmanaged\n    * @param _role Identifier for the group of actions being unmanaged\n    */\n    function removePermissionManager(address _app, bytes32 _role)\n        onlyPermissionManager(_app, _role)\n        external\n    {\n        _setPermissionManager(address(0), _app, _role);\n    }\n\n    /**\n     * @notice Get parameters for permission array length\n     * @param _entity Address of the whitelisted entity that will be able to perform the role\n     * @param _app Address of the app\n     * @param _role Identifier for a group of actions in app\n     * @return Length of the array\n     */\n    function getPermissionParamsLength(address _entity, address _app, bytes32 _role) external view returns (uint) {\n        return permissionParams[permissions[permissionHash(_entity, _app, _role)]].length;\n    }\n\n    /**\n    * @notice Get parameter for permission\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app\n    * @param _role Identifier for a group of actions in app\n    * @param _index Index of parameter in the array\n    * @return Parameter (id, op, value)\n    */\n    function getPermissionParam(address _entity, address _app, bytes32 _role, uint _index) external view returns (uint8 id, uint8 op, uint240 value) {\n        Param storage param = permissionParams[permissions[permissionHash(_entity, _app, _role)]][_index];\n        id = param.id;\n        op = param.op;\n        value = param.value;\n    }\n\n    /**\n    * @dev Get manager for permission\n    * @param _app Address of the app\n    * @param _role Identifier for a group of actions in app\n    * @return address of the manager for the permission\n    */\n    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\n        return permissionManager[roleHash(_app, _role)];\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission statu\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _where Identifier for a group of actions in app\n    * @param _how Permission parameters\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\n        uint256[] memory how;\n        uint256 intsLength = _how.length / 32;\n        assembly {\n            how := _how // forced casting\n            mstore(how, intsLength)\n        }\n        // _how is invalid from this point fwd\n        return hasPermission(_who, _where, _what, how);\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\n        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\n        if (whoParams != bytes32(0) && evalParams(whoParams, _who, _where, _what, _how)) {\n            return true;\n        }\n\n        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\n        if (anyParams != bytes32(0) && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\n        uint256[] memory empty = new uint256[](0);\n        return hasPermission(_who, _where, _what, empty);\n    }\n\n    function evalParams(\n        bytes32 _paramsHash,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) public view returns (bool)\n    {\n        if (_paramsHash == EMPTY_PARAM_HASH) {\n            return true;\n        }\n\n        return evalParam(_paramsHash, 0, _who, _where, _what, _how);\n    }\n\n    /**\n    * @dev Internal createPermission for access inside the kernel (on instantiation)\n    */\n    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\n        // only allow permission creation (or re-creation) when there is no manager\n        require(getPermissionManager(_app, _role) == address(0));\n\n        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\n        _setPermissionManager(_manager, _app, _role);\n    }\n\n    /**\n    * @dev Internal function called to actually save the permission\n    */\n    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\n        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\n\n        SetPermission(_entity, _app, _role, _paramsHash != bytes32(0));\n    }\n\n    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\n        bytes32 paramHash = keccak256(_encodedParams);\n        Param[] storage params = permissionParams[paramHash];\n\n        if (params.length == 0) { // params not saved before\n            for (uint256 i = 0; i < _encodedParams.length; i++) {\n                uint256 encodedParam = _encodedParams[i];\n                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\n                params.push(param);\n            }\n        }\n\n        return paramHash;\n    }\n\n    function evalParam(\n        bytes32 _paramsHash,\n        uint32 _paramId,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) internal view returns (bool)\n    {\n        if (_paramId >= permissionParams[_paramsHash].length) {\n            return false; // out of bounds\n        }\n\n        Param memory param = permissionParams[_paramsHash][_paramId];\n\n        if (param.id == LOGIC_OP_PARAM_ID) {\n            return evalLogic(param, _paramsHash, _who, _where, _what, _how);\n        }\n\n        uint256 value;\n        uint256 comparedTo = uint256(param.value);\n\n        // get value\n        if (param.id == ORACLE_PARAM_ID) {\n            value = checkOracle(address(param.value), _who, _where, _what, _how) ? 1 : 0;\n            comparedTo = 1;\n        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\n            value = blockN();\n        } else if (param.id == TIMESTAMP_PARAM_ID) {\n            value = time();\n        } else if (param.id == SENDER_PARAM_ID) {\n            value = uint256(msg.sender);\n        } else if (param.id == PARAM_VALUE_PARAM_ID) {\n            value = uint256(param.value);\n        } else {\n            if (param.id >= _how.length) {\n                return false;\n            }\n            value = uint256(uint240(_how[param.id])); // force lost precision\n        }\n\n        if (Op(param.op) == Op.RET) {\n            return uint256(value) > 0;\n        }\n\n        return compare(value, Op(param.op), comparedTo);\n    }\n\n    function evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n        if (Op(_param.op) == Op.IF_ELSE) {\n            var (condition, success, failure) = decodeParamsList(uint256(_param.value));\n            bool result = evalParam(_paramsHash, condition, _who, _where, _what, _how);\n\n            return evalParam(_paramsHash, result ? success : failure, _who, _where, _what, _how);\n        }\n\n        var (v1, v2,) = decodeParamsList(uint256(_param.value));\n        bool r1 = evalParam(_paramsHash, v1, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.NOT) {\n            return !r1;\n        }\n\n        if (r1 && Op(_param.op) == Op.OR) {\n            return true;\n        }\n\n        if (!r1 && Op(_param.op) == Op.AND) {\n            return false;\n        }\n\n        bool r2 = evalParam(_paramsHash, v2, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.XOR) {\n            return r1 != r2;\n        }\n\n        return r2; // both or and and depend on result of r2 after checks\n    }\n\n    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\n        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\n        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\n        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\n        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\n        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\n        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\n        return false;\n    }\n\n    function checkOracle(address _oracleAddr, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n        bytes4 sig = ACLOracle(_oracleAddr).canPerform.selector;\n\n        // a raw call is required so we can return false if the call reverts, rather than reverting\n        bool ok = _oracleAddr.call(sig, _who, _where, _what, 0x80, _how.length, _how);\n        // 0x80 is the position where the array that goes there starts\n\n        if (!ok) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := returndatasize }\n        if (size != 32) {\n            return false;\n        }\n\n        bool result;\n        assembly {\n            let ptr := mload(0x40)       // get next free memory ptr\n            returndatacopy(ptr, 0, size) // copy return from above `call`\n            result := mload(ptr)         // read data at ptr and set it to result\n            mstore(ptr, 0)               // set pointer memory to 0 so it still is the next free ptr\n        }\n\n        return result;\n    }\n\n    /**\n    * @dev Internal function that sets management\n    */\n    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\n        permissionManager[roleHash(_app, _role)] = _newManager;\n        ChangePermissionManager(_app, _role, _newManager);\n    }\n\n    function roleHash(address _where, bytes32 _what) pure internal returns (bytes32) {\n        return keccak256(uint256(1), _where, _what);\n    }\n\n    function permissionHash(address _who, address _where, bytes32 _what) pure internal returns (bytes32) {\n        return keccak256(uint256(2), _who, _where, _what);\n    }\n\n    function time() internal view returns (uint64) { return uint64(block.timestamp); } // solium-disable-line security/no-block-members\n\n    function blockN() internal view returns (uint256) { return block.number; }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol": {
      "keccak256": "0x5bf6b2ceab21c1f8b31b6e797ae12974a655e46e142aeb12b3560ed912a4dd01",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\nlibrary ScriptHelpers {\n    // To test with JS and compare with actual encoder. Maintaining for reference.\n    // t = function() { return IEVMScriptExecutor.at('0x4bcdd59d6c77774ee7317fc1095f69ec84421e49').contract.execScript.getData(...[].slice.call(arguments)).slice(10).match(/.{1,64}/g) }\n    // run = function() { return ScriptHelpers.new().then(sh => { sh.abiEncode.call(...[].slice.call(arguments)).then(a => console.log(a.slice(2).match(/.{1,64}/g)) ) }) }\n    // This is truly not beautiful but lets no daydream to the day solidity gets reflection features\n\n    function abiEncode(bytes _a, bytes _b, address[] _c) public pure returns (bytes d) {\n        return encode(_a, _b, _c);\n    }\n\n    function encode(bytes memory _a, bytes memory _b, address[] memory _c) internal pure returns (bytes memory d) {\n        // A is positioned after the 3 position words\n        uint256 aPosition = 0x60;\n        uint256 bPosition = aPosition + 32 * abiLength(_a);\n        uint256 cPosition = bPosition + 32 * abiLength(_b);\n        uint256 length = cPosition + 32 * abiLength(_c);\n\n        d = new bytes(length);\n        assembly {\n            // Store positions\n            mstore(add(d, 0x20), aPosition)\n            mstore(add(d, 0x40), bPosition)\n            mstore(add(d, 0x60), cPosition)\n        }\n\n        // Copy memory to correct position\n        copy(d, getPtr(_a), aPosition, _a.length);\n        copy(d, getPtr(_b), bPosition, _b.length);\n        copy(d, getPtr(_c), cPosition, _c.length * 32); // 1 word per address\n    }\n\n    function abiLength(bytes memory _a) internal pure returns (uint256) {\n        // 1 for length +\n        // memory words + 1 if not divisible for 32 to offset word\n        return 1 + (_a.length / 32) + (_a.length % 32 > 0 ? 1 : 0);\n    }\n\n    function abiLength(address[] _a) internal pure returns (uint256) {\n        // 1 for length + 1 per item\n        return 1 + _a.length;\n    }\n\n    function copy(bytes _d, uint256 _src, uint256 _pos, uint256 _length) internal pure {\n        uint dest;\n        assembly {\n            dest := add(add(_d, 0x20), _pos)\n        }\n        memcpy(dest, _src, _length + 32);\n    }\n\n    function getPtr(bytes memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getPtr(address[] memory _x) internal pure returns (uint256 ptr) {\n        assembly {\n            ptr := _x\n        }\n    }\n\n    function getSpecId(bytes _script) internal pure returns (uint32) {\n        return uint32At(_script, 0);\n    }\n\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := mload(add(_data, add(0x20, _location)))\n        }\n    }\n\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n            0x1000000000000000000000000)\n        }\n    }\n\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n            0x100000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := add(_data, add(0x20, _location))\n        }\n    }\n\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n        bytes memory payload = new bytes(4);\n        assembly { mstore(add(payload, 0x20), _sig) }\n        return payload;\n    }\n\n    function memcpy(uint _dest, uint _src, uint _len) internal pure {\n        uint256 src = _src;\n        uint256 dest = _dest;\n        uint256 len = _len;\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol": {
      "keccak256": "0x6a4beed810085f11cda9d50c3547ac4cc2100d9dc18ab4982ff11dd483410012",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ninterface IEVMScriptExecutor {\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol": {
      "keccak256": "0x460ff768028031e444267cad9d848b6e98182c3721d16013afd5949444701e84",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\n\ncontract EVMScriptRegistryConstants {\n    /* Hardcoded constants to save gas\n    // repeated definitions from KernelStorage, to avoid out of gas issues\n    bytes32 constant public APP_ADDR_NAMESPACE = keccak256(\"app\");\n\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\"evmreg\");\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP = keccak256(APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n    */\n    bytes32 constant public APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\n    bytes32 constant public EVMSCRIPT_REGISTRY_APP = 0x34f01c17e9be6ddbf2c61f37b5b1fb9f1a090a975006581ad19bda1c4d382871;\n}\n\n\ninterface IEVMScriptRegistry {\n    function addScriptExecutor(address executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    function getScriptExecutor(bytes script) public view returns (address);\n}\n"
    },
    "./node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol": {
      "keccak256": "0x85d0a5051c5e867b0b15b756789911871ae746f36462cb774557682f90e7fa78",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./ScriptHelpers.sol\";\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"../apps/AppStorage.sol\";\n\n\ncontract EVMScriptRunner is AppStorage, EVMScriptRegistryConstants {\n    using ScriptHelpers for bytes;\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist) protectState internal returns (bytes output) {\n        // TODO: Too much data flying around, maybe extracting spec id here is cheaper\n        address executorAddr = getExecutor(_script);\n        require(executorAddr != address(0));\n\n        bytes memory calldataArgs = _script.encode(_input, _blacklist);\n        bytes4 sig = IEVMScriptExecutor(0).execScript.selector;\n\n        require(executorAddr.delegatecall(sig, calldataArgs));\n\n        bytes memory ret = returnedDataDecoded();\n\n        require(ret.length > 0);\n\n        return ret;\n    }\n\n    function getExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getExecutorRegistry().getScriptExecutor(_script));\n    }\n\n    // TODO: Internal\n    function getExecutorRegistry() internal view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel.getApp(EVMSCRIPT_REGISTRY_APP);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    /**\n    * @dev copies and returns last's call data. Needs to ABI decode first\n    */\n    function returnedDataDecoded() internal pure returns (bytes ret) {\n        assembly {\n            let size := returndatasize\n            switch size\n            case 0 {}\n            default {\n                ret := mload(0x40) // free mem ptr get\n                mstore(0x40, add(ret, add(size, 0x20))) // free mem ptr set\n                returndatacopy(ret, 0x20, sub(size, 0x20)) // copy return data\n            }\n        }\n        return ret;\n    }\n\n    modifier protectState {\n        address preKernel = kernel;\n        bytes32 preAppId = appId;\n        _; // exec\n        require(kernel == preKernel);\n        require(appId == preAppId);\n    }\n}\n"
    },
    "./node_modules/@aragon/os/contracts/apps/AragonApp.sol": {
      "keccak256": "0x04bd38b82d31aff08b67def2e1637482fdb91f1f44f4ec497f4e7416c5f83dfb",
      "urls": [
        "file:///Users/satya/Development/liquidpledging/node_modules/@aragon/os/contracts/apps/AragonApp.sol"
      ],
      "content": "pragma solidity ^0.4.18;\n\nimport \"./AppStorage.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/VaultRecoverable.sol\";\nimport \"../evmscript/EVMScriptRunner.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\n\n\n// ACLSyntaxSugar and EVMScriptRunner are not directly used by this contract, but are included so\n// that they are automatically usable by subclassing contracts\ncontract AragonApp is AppStorage, Initializable, ACLSyntaxSugar, VaultRecoverable, EVMScriptRunner {\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)));\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] params) {\n        require(canPerform(msg.sender, _role, params));\n        _;\n    }\n\n    function canPerform(address _sender, bytes32 _role, uint256[] params) public view returns (bool) {\n        bytes memory how; // no need to init memory as it is never used\n        if (params.length > 0) {\n            uint256 byteLength = params.length * 32;\n            assembly {\n                how := params // forced casting\n                mstore(how, byteLength)\n            }\n        }\n        return address(kernel) == 0 || kernel.hasPermission(_sender, address(this), _role, how);\n    }\n\n    function getRecoveryVault() public view returns (address) {\n        // Funds recovery via a vault is only available when used with a kernel\n        require(address(kernel) != 0);\n        return kernel.getRecoveryVault();\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@aragon/os/contracts/kernel/Kernel.sol=./node_modules/@aragon/os/contracts/kernel/Kernel.sol",
      "@aragon/os/contracts/acl/IACL.sol=./node_modules/@aragon/os/contracts/acl/IACL.sol",
      "@aragon/os/contracts/common/IVaultRecoverable.sol=./node_modules/@aragon/os/contracts/common/IVaultRecoverable.sol",
      "@aragon/os/contracts/kernel/IKernel.sol=./node_modules/@aragon/os/contracts/kernel/IKernel.sol",
      "@aragon/os/contracts/kernel/KernelStorage.sol=./node_modules/@aragon/os/contracts/kernel/KernelStorage.sol",
      "@aragon/os/contracts/acl/ACLSyntaxSugar.sol=./node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol",
      "@aragon/os/contracts/lib/misc/ERCProxy.sol=./node_modules/@aragon/os/contracts/lib/misc/ERCProxy.sol",
      "@aragon/os/contracts/apps/AppStorage.sol=./node_modules/@aragon/os/contracts/apps/AppStorage.sol",
      "@aragon/os/contracts/common/Initializable.sol=./node_modules/@aragon/os/contracts/common/Initializable.sol",
      "@aragon/os/contracts/common/IsContract.sol=./node_modules/@aragon/os/contracts/common/IsContract.sol",
      "@aragon/os/contracts/common/EtherTokenConstant.sol=./node_modules/@aragon/os/contracts/common/EtherTokenConstant.sol",
      "@aragon/os/contracts/lib/zeppelin/token/ERC20Basic.sol=./node_modules/@aragon/os/contracts/lib/zeppelin/token/ERC20Basic.sol",
      "@aragon/os/contracts/lib/zeppelin/token/ERC20.sol=./node_modules/@aragon/os/contracts/lib/zeppelin/token/ERC20.sol",
      "@aragon/os/contracts/common/VaultRecoverable.sol=./node_modules/@aragon/os/contracts/common/VaultRecoverable.sol",
      "@aragon/os/contracts/common/DelegateProxy.sol=./node_modules/@aragon/os/contracts/common/DelegateProxy.sol",
      "@aragon/os/contracts/common/DepositableDelegateProxy.sol=./node_modules/@aragon/os/contracts/common/DepositableDelegateProxy.sol",
      "@aragon/os/contracts/apps/AppProxyBase.sol=./node_modules/@aragon/os/contracts/apps/AppProxyBase.sol",
      "@aragon/os/contracts/apps/AppProxyUpgradeable.sol=./node_modules/@aragon/os/contracts/apps/AppProxyUpgradeable.sol",
      "@aragon/os/contracts/apps/AppProxyPinned.sol=./node_modules/@aragon/os/contracts/apps/AppProxyPinned.sol",
      "@aragon/os/contracts/factory/AppProxyFactory.sol=./node_modules/@aragon/os/contracts/factory/AppProxyFactory.sol",
      "@aragon/os/contracts/acl/ACL.sol=./node_modules/@aragon/os/contracts/acl/ACL.sol",
      "@aragon/os/contracts/evmscript/ScriptHelpers.sol=./node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol",
      "@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol=./node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol",
      "@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol=./node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol",
      "@aragon/os/contracts/evmscript/EVMScriptRunner.sol=./node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol",
      "@aragon/os/contracts/apps/AragonApp.sol=./node_modules/@aragon/os/contracts/apps/AragonApp.sol"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "metadata",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "abi",
          "evm.methodIdentifiers",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap"
        ]
      }
    }
  }
}